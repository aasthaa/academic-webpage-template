ccCtrls[1,]
ccCtrls$Y
ctrlsRisk[1,]
nBoot
nBoot <- 5
nSimul <- 2
ruX_star <- vector(length=nSimul)#
   pnfX_star <- vector(length=nSimul)#
   rocinvX_star <- vector(length=nSimul)#
   hrcX_star <- vector(length=nSimul)#
   hrnX_star <- vector(length=nSimul)#
   #Nonparametric Estimates#
#   rocXY_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
#   rocXY_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
#   aucXY_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
#   aucXY_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   rocX_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocX_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   #ruXY_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #ruXY_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #pnfXY_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #pnfXY_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #rocinvXY_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #rocinvXY_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #hrcXY_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #hrcXY_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #hrnXY_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #hrnXY_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #bEvent_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #bNonevent_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #bEvent_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #bNonevent_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   quantUsed_star <- quantUsed_semi_HP_star <- quantUsed_param_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   quantJustAfter_star <- quantJustAfter_semi_HP_star <- quantJustAfter_param_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   #####Bootstrap coverage#
   #rocX_bootCov <- vector(length=nSimul)#
   #aucX_bootCov <- vector(length=nSimul)#
   rocX_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocDelta_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocX_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocDelta_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucDelta_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucDelta_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nri_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nri_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idi_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idi_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tg_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tg_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   #quantUsed_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   #quantJustAfter_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   #####Bootstrap IQR#
   #rocX_bootIQR <- vector(length=nSimul)#
   #aucX_bootIQR <- vector(length=nSimul)#
   rocX_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocDelta_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocX_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocDelta_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucDelta_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucDelta_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nri_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nri_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idi_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idi_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tg_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tg_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   #quantUsed_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   #quantJustAfter_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   #####Bootstrap Mean#
   rocX_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocDelta_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocX_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocDelta_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucDelta_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucDelta_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nri_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nri_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idi_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idi_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tg_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tg_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   #####Bootstrap Std Error#
   rocX_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocDelta_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocX_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocDelta_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucDelta_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucDelta_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nri_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nri_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idi_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idi_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tg_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tg_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   for(s in 1:nSimul) {#
      print(paste("s:",s))#
      rocX.star1 <- aucX.star1 <- rocXY.star1.A <- aucXY.star1.A <- nriEvent.star1.A <- nriNonevent.star1.A <- #
         idiEvent.star1.A <- idiNonevent.star1.A <- tgEvent.star1.A <- tgNonevent.star1.A <- #
         rocX.star1 <- aucX.star1 <- rocXY.star1.B <- aucXY.star1.B <- nriEvent.star1.B <- nriNonevent.star1.B <- #
         idiEvent.star1.B <- idiNonevent.star1.B <- tgEvent.star1.B <- tgNonevent.star1.B <- #
         quantUsed.star1.A <- quantUsed.star1.B <- quantJustAfter.star1.A <- quantJustAfter.star1.B <-#
         as.data.frame(matrix(ncol=length(ccSubs)*3, nrow=nBoot))#
      names(rocX.star1) <- names(aucX.star1) <- names(rocXY.star1.A) <- names(aucXY.star1.A) <- names(nriEvent.star1.A) <- names(nriNonevent.star1.A) <- #
      names(idiEvent.star1.A) <- names(idiNonevent.star1.A) <- names(tgEvent.star1.A) <- names(tgNonevent.star1.A) <- #
      names(rocXY.star1.B) <- names(aucXY.star1.B) <- names(nriEvent.star1.B) <- names(nriNonevent.star1.B) <- #
      names(idiEvent.star1.B) <- names(idiNonevent.star1.B) <- names(tgEvent.star1.B) <- names(tgNonevent.star1.B) <- #
      names(quantUsed.star1.A) <- names(quantUsed.star1.B) <- names(quantJustAfter.star1.A) <- names(quantJustAfter.star1.B) <-#
      c("unmatch_non","freq_non","hybrid_non","unmatch_semi","freq_semi","hybrid_semi","unmatch_param","freq_param","hybrid_param")#
      randCohort <- sample(seq(1:PopnN), size=N, replace = FALSE)#
      cohort <- as.data.frame(dataset[randCohort,])#
      #names(cohort) <- c("X","Y","dis")#
      cohortD <<- cohort$dis#
      cohortX <<- cohort$X#
      rocResults <- comproc(d="cohortD", markers="cohortX", roc=t, auc=T, nobstrap=T)#
      aucX_A_star[s,] <- aucX_B_star[s,] <- rocResults[1]#
      rocX_A_star[s] <- rocX_B_star[s] <- rocResults[2]#
      #rocX_star[s] <- rocResults[2]#
      #Fit baseline risk model to entire cohort and get logit(P(D=1|X)) for each subject in case-ctrl subset#
      mod <- glm(dis~X,family=binomial(link="logit"),data=cohort)#
      cohort$rxCohort <- mod$fitted.values#
      cohort$origCCsubset <- 0#
      #Select nested cases#
      casesRisk  <- subset(cohort, dis==1)#
      randCases <- sample(seq(1:(dim(casesRisk)[1])), size=nd, replace = FALSE)#
      casesRisk$Y[-randCases] <- NA#
      #casesRisk$origCCsubset <- 0#
      casesRisk$origCCsubset[randCases] <- 1#
      casesRiskSub <- casesRisk[randCases,]#
      #modYX_cases <- lm(Y ~ X, data=ccCases)#
      modYX_cases <- lm(Y ~ X, data=casesRiskSub)#
      sigma_cases <- sd(modYX_cases$residuals)#
      modYX_resid_cases <- modYX_cases$residuals/sigma_cases#
      prevCohort <- nrow(casesRisk)/nrow(cohort)#
      #Select nested controls#
      ctrlsRisk <- subset(cohort, dis==0)#
      for(cc in 1:length(ccSubs)) {#
      	 ctrlsRisk$origCCsubset <- 0#
         if(ccSubs[cc]=="simple") {#
            #Simple Case-Control Design#
            randCtrls <- sample(seq(1:(dim(ctrlsRisk)[1])), size=r*nd, replace = FALSE)#
            #ctrlsRisk$origCCsubset[randCtrls] <- 1#
            ctrlsRiskSub <- ctrlsRisk[randCtrls,]#
            ccSubset <- as.data.frame( rbind(ctrlsRiskSub, casesRiskSub) )#
            origCtrls <- randCtrls#
         }#
         if(ccSubs[cc]=="freqMatch" | ccSubs[cc]=="hybrid") {#
            #Matched Case-Control Design#
            #Do matching to select controls#
            ctrlsRisk_overlap <- ctrlsRisk[ctrlsRisk$X >= min(casesRiskSub$X),]#
            binCuts <- cut2(ctrlsRisk_overlap$X, g=numBins, onlycuts=T)[2:(numBins)]#
            XctrlBins <- as.numeric(cut2(ctrlsRisk$X, cuts=binCuts ))#
            XcaseBins <- as.numeric( cut2(casesRiskSub$X, cuts=binCuts ))#
            if(is.na(mean(XctrlBins))) {#
               naIndices <- which(is.na(XctrlBins))#
               XctrlBins[naIndices] <- as.numeric( cut2(ctrlsRisk$X[naIndices], cuts=binCuts))#
            }#
            if(is.na(mean(XcaseBins))) {#
               naIndices <- which(is.na(XcaseBins))#
               XcaseBins[naIndices] <- as.numeric( cut2(casesRiskSub$X[naIndices], cuts=binCuts))#
            }#
            #Put overlapping controls in bins#
            #XctrlBins <- as.numeric(cut2(Xctrl_overlapToUseForMakingBins, g=numBins[b]))#
            #XctrlBins <- as.numeric(cut2(ctrlsRisk$X, g=numBins[b]))#
            #Controls that are smallest than the smallest case go in bin 1, so add those in#
            nbins_cases <- unlist( lapply(seq(1:numBins), FUN=function(x){sum(XcaseBins==x)} ) )#
            if(ccSubs[cc]=="freqMatch") {#
               #Frequency-Matched Design#
               matchedCtrls <- lapply( seq(1:numBins), FUN=function(x) #
                  { sample(which(XctrlBins==x),r*(nbins_cases[x])) } )#
               #ctrlsRisk$origCCsubset[unlist(matchedCtrls)] <- 1#
               XctrlSubBins <- XctrlBins[unlist(matchedCtrls)]#
               ctrlsRiskSub <- ctrlsRisk[unlist(matchedCtrls),]#
               ccSubset <- as.data.frame( rbind(ctrlsRiskSub,casesRiskSub) )#
               origCtrls <- unlist(matchedCtrls)#
            }#
            if(ccSubs[cc]=="hybrid") {#
               #Hybrid Matched-Unmatched Design#
               nbins_check <- r1*(nbins_cases)#
               if(sum(floor(nbins_check)) < r1*nd) {#
               	  indices <- which(floor(nbins_check) != nbins_check)#
               	  pickIndicesToRoundUp <- sample(length(indices), 0.5*length(indices), replace=F)#
               	  indicesToRoundUp <- indices[pickIndicesToRoundUp]#
               	  nbins_check[indicesToRoundUp] <- ceiling(nbins_check[indicesToRoundUp])#
               	  nbins_check[indices[-indicesToRoundUp]] <- floor(nbins_check[indices[-indicesToRoundUp]])#
               }#
               matchedCtrls <- lapply( seq(1:numBins), FUN=function(x)#
                  { sample(which(XctrlBins==x), nbins_check[x] ) } )#
#               matchedCtrls <- lapply( seq(1:numBins), FUN=function(x)#
#                  { sample(which(XctrlBins==x),r1*(nbins_cases[x])) } )#
               remainingCtrls <- XctrlBins#
               remainingCtrls[unlist(matchedCtrls)] <- 0#
               SRS <- sample(which(remainingCtrls!=0),(r-r1)*nd,replace=F)#
               #ctrlsRisk$origCCsubset[c(unlist(matchedCtrls),SRS)] <- 1#
               XctrlSubBins <- c(XctrlBins[unlist(matchedCtrls)], XctrlBins[SRS])#
               ctrlsRiskSub <- ctrlsRisk[c(unlist(matchedCtrls),unlist(SRS)),]#
               ccSubset <- as.data.frame( rbind(ctrlsRiskSub,casesRiskSub) )#
               origCtrls <- c(unlist(matchedCtrls),SRS)#
            }#
         }#
         ctrlsRisk$origCCsubset[origCtrls] <- 1#
         #ctrlsRisk$Y[-origCtrls] <- NA#
         SxyResults <- getSxy(ccSubset, mod, nd, r, casesRisk, ctrlsRisk)#
         mod_cc <- SxyResults[[2]]#
         Sxy <- SxyResults[[1]]#
         ccSubset$SxyA <- Sxy[,1]#
         ccSubset$SxyB <- Sxy[,2]#
         ccCtrls <- subset(ccSubset, dis==0)#
         ccCases <- subset(ccSubset, dis==1)#
##Check distribution of control residuals within each stratum#
# plot(density(modYX_resid[XctrlSubBins==1]), ylim=c(0,0.5))#
# lines(density(modYX_resid[XctrlSubBins==2]))#
# lines(density(modYX_resid[XctrlSubBins==3]), col="red")#
# lines(density(modYX_resid[XctrlSubBins==4]), col="blue")#
##Check distribution of case residuals within each stratum#
# plot(density(modYX_resid_cases[XcaseBins==1]), ylim=c(0,0.5))#
# lines(density(modYX_resid_cases[XcaseBins==2]))#
# lines(density(modYX_resid_cases[XcaseBins==3]), col="red")#
# lines(density(modYX_resid_cases[XcaseBins==4]), col="blue")#
         if(semiparam) {#
            modYX <- lm(Y ~ X, data=ccCtrls)#
            sigma <- sd(modYX$residuals)#
            modYX_resid <- modYX$residuals/sigma#
    	      modYX_fitted <- modYX$coeff[1] + modYX$coeff[2]*(ctrlsRisk$X)#
            F0 <- ecdf(modYX_resid)#
            ##modYX <- lm(Y ~ ns(X, df=2), data=ccCtrls)#
            #modYX <- lm(Y ~ ns(X), data=ccCtrls)#
            #sigma2Hat <- (modYX$residuals)^2#
            ##modYX_sigma <- glm(sigma2Hat ~ ns(X, df=2), family=gaussian(link="log"), data=ccCtrls)#
            #modYX_sigma <- glm(sigma2Hat ~ ns(X), family=gaussian(link="log"), data=ccCtrls)#
            #muX <- modYX$fitted.values#
            #sigmaX2 <- predict(modYX_sigma, type="response")#
            ##sigmaX2[which(sigmaX2 < 0)] <- NA#
            #sigmaX <- sqrt(sigmaX2)#
            #modYX_resid <- (ccCtrls$Y - muX)/sigmaX#
            #F0 <- ecdf(modYX_resid)#
            ##muX_cohort <- modYX$coeff[1] + modYX$coeff[2:3]*ns(ctrlsRisk$X, df=2)#
            ##sigmaX_cohort <- exp(modYX_sigma$coeff[1] + modYX_sigma$coeff[2:3]*ns(ctrlsRisk$X, df=2))#
            #muX_cohort <- modYX$coeff[1] + modYX$coeff[2]*ns(ctrlsRisk$X)#
            #sigmaX_cohort <- exp(modYX_sigma$coeff[1] + modYX_sigma$coeff[2]*ns(ctrlsRisk$X))#
            #muX_cohort <- modYX$coeff[1] + modYX$coeff[2]*(ctrlsRisk$X)#
            #sigmaX_cohort <- exp(modYX_sigma$coeff[1] + modYX_sigma$coeff[2]*(ctrlsRisk$X))#
            for(sxy in 1:ncol(Sxy)) {#
               if(methA & sxy==1)#
                  cThreshY <- mod$coeff[1] + (ctrlsRisk$X)*mod$coeff[2] - mod_cc$coeff[1] - #
                     mod_cc$coeff[2]*(ctrlsRisk$X) + mod_cc$coeff[3] + mod_cc$coeff[4]*(ctrlsRisk$X)#
               else#
                  cThreshY <- mod_cc$coeff[3] + mod_cc$coeff[4]*(ctrlsRisk$X) + log(nrow(casesRisk)/nrow(ctrlsRisk)) - log(nd/(r*nd))#
               if(roc) {#
                  cThresh <- seq(max(Sxy[1:(r*nd),sxy])+.001,min(Sxy[1:(r*nd),sxy])-.001,by=-0.001)#
                  #semi-parametric, using HP#
                  for(k in 1:length(cThresh)) {#
                     cThreshY_curr <- ( log(cThresh[k]/(1-cThresh[k])) - cThreshY)/mod_cc$coeff[5]#
                     quant <- mean( F0((cThreshY_curr - modYX_fitted)/sigma) )#
                     #quant <- mean( F0((cThreshY_curr - muX_cohort)/sigmaX_cohort) )#
                     if(quant >= 1-t) currQuant <- quant#
                     if(k<length(cThresh) & quant < (1-t)) {#
                        quantUsed_semi_HP_star[s,cc] <- currQuant#
                        break#
                     }#
                  }#
                  cFPF0.05 <- ifelse(k==1, NA, cThresh[k-1])#
                  quantJustAfter_semi_HP_star[s,cc] <- quant#
                  if(methA & sxy==1)#
                     rocXY_A_star[s,cc+3] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy[((r*nd+1):(nrow(Sxy))),sxy] <= cFPF0.05))#
                  else#
                     rocXY_B_star[s,cc+3] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy[(r*nd+1):(nrow(Sxy)),sxy] <= cFPF0.05))#
               }#
               if(auc) {#
                  #Sxy_auc_param <- vector(length=nd)#
                  Sxy_auc_HP <- vector(length=nd)#
                  for(nd_i in 1:nd) {#
                     cThreshY_curr <- ( log(Sxy[(nd_i + r*nd),sxy]/(1-Sxy[(nd_i + r*nd),sxy])) - cThreshY)/mod_cc$coeff[5]#
                     #Sxy_auc_param[nd_i] <- mean( pnorm(cThreshY_curr, mean=rho*ctrlsRisk$X, sd=sqrt(1-rho^2)) )#
                     Sxy_auc_HP[nd_i] <- mean( F0(cThreshY_curr - modYX_fitted) )#
                  }#
                  if(methA & sxy==1) {#
                     aucXY_A_star[s,cc+3] <- mean(Sxy_auc_HP)#
                     #aucXY_A_star[s,cc+6] <- mean(Sxy_auc_param)#
                  }#
                  else {#
                     aucXY_B_star[s,cc+3] <- mean(Sxy_auc_HP)#
                     #aucXY_B_star[s,cc+6] <- mean(Sxy_auc_param)#
                  }#
               }#
               if(nri) {#
                  cThreshY_curr <- ( log(ctrlsRisk$rxCohort/(1-ctrlsRisk$rxCohort)) - cThreshY)/mod_cc$coeff[5]#
                  #calcNRI_nonparam(Sxy[((nd*r+1):(nd*r+nd)), sxy], ccCases$rxCohort, NULL, NULL , match=F)#
                  #calcNRI_semi( , match=F)#
                  #calcNRI_param( , match=F)#
                  currEvent <- 2*mean( Sxy[((nd*r+1):(nd*r+nd)), sxy] > ccCases$rxCohort ) - 1#
                  #currNonevent_param <- 2*(mean( pnorm(cThreshY_curr, mean=rho*ctrlsRisk$X, sd=sqrt(1-rho^2)) )) - 1#
                  currNonevent_HP <- 2*(mean( F0(cThreshY_curr - modYX_fitted) )) - 1#
                  if(methA & sxy==1){#
                     #nriEvent_A_star[s,cc+3] <- nriEvent_A_star[s,cc+6] <- currEvent#
                     #nriNonevent_A_star[s,cc+6] <- currNonevent_param#
                     nriEvent_A_star[s,cc+3] <- currEvent#
                     nriNonevent_A_star[s,cc+3] <- currNonevent_HP#
                  }#
                  else {#
                     #nriEvent_B_star[s,cc+3] <- nriEvent_B_star[s,cc+6] <- currEvent#
                     #nriNonevent_B_star[s,cc+6] <- currNonevent_param#
                     nriEvent_B_star[s,cc+3] <- currEvent#
                     nriNonevent_B_star[s,cc+3] <- currNonevent_HP#
                  }#
               }#
               if(idi) {#
                  #cThresh <- seq(0,1,by=0.005)#
                  cThresh <- seq(0,1,by=0.0001)#
                  ##quant_yxCond#
                  #quants <- vector(length=length(cThresh))#
                  #for(k in 1:length(cThresh)) {#
                  #   cThreshY_curr <- ( log(cThresh[k]/(1-cThresh[k])) - cThreshY)/mod_cc$coeff[5]#
                  #   quants[k] <- 1 - mean( pnorm(cThreshY_curr, mean=rho*ctrlsRisk$X, sd=sqrt(1-rho^2)) )#
                  #}#
                  #currNonevent_yxCond <- mean(ctrlsRisk$rxCohort) - mean(quants)#
                  #quant_HP#
                  quants <- vector(length=length(cThresh))#
                  for(k in 1:length(cThresh)) {#
                     cThreshY_curr <- ( log(cThresh[k]/(1-cThresh[k])) - cThreshY)/mod_cc$coeff[5]#
                     quants[k] <- 1 - mean( F0(cThreshY_curr - modYX_fitted) )#
                  }#
                  currNonevent_HP <- mean(ctrlsRisk$rxCohort) - mean(quants)#
                  currEvent <- mean(Sxy[((nd*r+1):(nd*r+nd)), sxy]) - mean(casesRisk$rxCohort)#
                  if(methA & sxy==1){#
                     #idiEvent_A_star[s,cc+3] <- idiEvent_A_star[s,cc+6] <- currEvent#
                     #idiNonevent_A_star[s,cc+6] <- currNonevent_yxCond#
                     idiEvent_A_star[s,cc+3] <- currEvent#
                     idiNonevent_A_star[s,cc+3] <- currNonevent_HP#
                  }#
                  else {#
                     #idiEvent_B_star[s,cc+3] <- idiEvent_B_star[s,cc+6] <- currEvent#
                     #idiNonevent_B_star[s,cc+6] <- currNonevent_yxCond#
                     idiEvent_B_star[s,cc+3] <- currEvent#
                     idiNonevent_B_star[s,cc+3] <- currNonevent_HP#
                  } #
               }#
               if(tg) {#
                  cThreshY_curr <- ( log(prevCohort/(1-prevCohort)) - cThreshY)/mod_cc$coeff[5]#
                  currEvent <- mean(Sxy[((nd*r+1):(nd*r+nd)), sxy] > prevCohort) - mean(casesRisk$rxCohort > prevCohort)#
                  #currNonevent_yxCond <- mean(ctrlsRisk$rxCohort > prevCohort) - 1 + mean( pnorm(cThreshY_curr, mean=rho*ctrlsRisk$X, sd=sqrt(1-rho^2)) )#
                  currNonevent_HP <- mean(ctrlsRisk$rxCohort > prevCohort) - 1 + mean( F0(cThreshY_curr - modYX_fitted) )#
                  if(methA & sxy==1){#
                     #tgEvent_A_star[s,cc+3] <- tgEvent_A_star[s,cc+6] <- currEvent#
                     #tgNonevent_A_star[s,cc+6] <- currNonevent_yxCond#
                     tgEvent_A_star[s,cc+3] <- currEvent#
                     tgNonevent_A_star[s,cc+3] <- currNonevent_HP#
                  }#
                  else {#
                     #tgEvent_B_star[s,cc+3] <- tgEvent_B_star[s,cc+6] <- currEvent#
                     #tgNonevent_B_star[s,cc+6] <- currNonevent_yxCond#
                     tgEvent_B_star[s,cc+3] <- currEvent#
                     tgNonevent_B_star[s,cc+3] <- currNonevent_HP#
                  }                  #
               }#
            } #sxy for loop#
         } #if semiparam#
         if(nonparam) {#
            if(ccSubs[cc]=="simple") {#
               if(roc | auc) {#
                  ccD <<- ccSubset$dis#
                  SxyA <<- ccSubset$SxyA#
                  #SxyA <<- Sxy[,1]#
                  rocResults <- comproc(d="ccD", markers="SxyA", roc=t, auc=T, nobstrap=T)#
                  aucXY_A_star[s,cc] <- rocResults[1]#
                  rocXY_A_star[s,cc] <- rocResults[2]#
                  SxyB <<- ccSubset$SxyB#
                  #SxyB <<- Sxy[,2]#
                  rocResults <- comproc(d="ccD", markers="SxyB", roc=t, auc=T, nobstrap=T)#
                  aucXY_B_star[s,cc] <- rocResults[1]#
                  rocXY_B_star[s,cc] <- rocResults[2]#
               }#
               if(nri) {#
                  nriEvent_A_star[s,cc] <- 2*mean( ccCases$SxyA > ccCases$rxCohort ) - 1#
                  nriNonevent_A_star[s,cc] <- 1 - 2*mean( ccCtrls$SxyA > ccCtrls$rxCohort )#
                  nriEvent_B_star[s,cc] <- 2*mean( ccCases$SxyB > ccCases$rxCohort )  - 1#
                  nriNonevent_B_star[s,cc] <- 1 - 2*mean( ccCtrls$SxyB > ccCtrls$rxCohort )#
               }#
               if(idi) {#
                  idiEvent_A_star[s,cc] <- mean(ccCases$SxyA) - mean(casesRisk$rxCohort)#
                  idiNonevent_A_star[s,cc] <- mean(ctrlsRisk$rxCohort) - mean(ccCtrls$SxyA )#
                  idiEvent_B_star[s,cc] <- mean(ccCases$SxyB) - mean(casesRisk$rxCohort)#
                  idiNonevent_B_star[s,cc] <- mean(ctrlsRisk$rxCohort) - mean(ccCtrls$SxyB )#
               }#
               if(tg) {#
                  tgEvent_A_star[s,cc] <- mean(ccCases$SxyA > prevCohort) - mean(casesRisk$rxCohort > prevCohort)#
                  tgNonevent_A_star[s,cc] <- mean(ctrlsRisk$rxCohort > prevCohort) - mean(ccCtrls$SxyA > prevCohort)#
                  tgEvent_B_star[s,cc] <- mean(ccCases$SxyB > prevCohort) - mean(casesRisk$rxCohort > prevCohort)#
                  tgNonevent_B_star[s,cc] <- mean(ctrlsRisk$rxCohort > prevCohort) - mean(ccCtrls$SxyB > prevCohort)#
               }#
            }#
            if(ccSubs[cc]=="freqMatch" | ccSubs[cc]=="hybrid") {#
               #Calculate fpfsXY#
               Nbins <- unlist( lapply(sort(unique(XctrlBins)), FUN=function(x){sum(XctrlBins==x)} ) )#
               binWeights <- Nbins/nrow(ctrlsRisk)#
               nbins <- unlist( lapply(sort(unique(XctrlBins)), FUN=function(x){sum(XctrlSubBins==x)} ) )#
               if(min(nbins) == 0) {#
                  print("Empty bins")#
                  countEmptyBins[,cc] <- countEmptyBins[,cc] + 1#
               }#
               else{ #
                  for(sxy in 1:ncol(Sxy)) {#
                     #Estimate case and ctrl popn distns of S(X,Y) using book, ch.2#
                     if(roc) { #
                        cThresh <- seq(max(Sxy[1:(r*nd),sxy])+.001,min(Sxy[1:(r*nd),sxy])-.001,by=-0.001)#
                        #cThresh <- seq(max(Sxy[,sxy])+.001,min(Sxy[,sxy])-.001,by=-0.001)#
                        #cThresh <- seq(max(ccCtrls$SxyA)+.001,min(ccCtrls$SxyA)-.001,by=-0.001)#
                        binSums <- rep(0,numBins)#
                        for(k in 1:length(cThresh)) {#
                           binSums <- unlist( lapply( seq(1:numBins), #
                              function(x){ sum(Sxy[which(XctrlSubBins==x),sxy] <= cThresh[k]) } ) )#
                           quant <- sum(binWeights * binSums/nbins)#
                           if(quant >= 1-t) currQuant <- quant#
                           if(k<length(cThresh) & quant < (1-t)) {#
                              quantUsed_star[s,cc] <- currQuant#
                              break#
                           }#
                        }#
                        cFPF0.05 <- ifelse(k==1, NA, cThresh[k-1])#
                        quantJustAfter_star[s,cc] <- quant#
                        if(methA & sxy==1)#
                           rocXY_A_star[s,cc] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy[((r*nd+1):(nrow(Sxy))),sxy] <= cFPF0.05))#
                        else#
                           rocXY_B_star[s,cc] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy[(r*nd+1):(nrow(Sxy)),sxy] <= cFPF0.05))#
                     }#
                     if(auc) {#
                        Sxy_auc <- vector(length=nd)#
                        for(nd_i in 1:nd) {#
                           binSums <- unlist( lapply( seq(1:numBins), function(x){ sum(Sxy[which(XctrlSubBins==x),sxy] > Sxy[nd_i + r*nd, sxy] ) } ) )#
                           Sxy_auc[nd_i] <- sum(binWeights * binSums/nbins)#
                        }#
                        currAuc <- 1 - mean(Sxy_auc)#
                        if(methA & sxy==1) aucXY_A_star[s,cc] <- currAuc#
                        else aucXY_B_star[s,cc] <- currAuc#
                     }#
                     if(nri) {#
                        currEvent <- 2*mean( Sxy[((nd*r+1):(nd*r+nd)), sxy] > ccCases$rxCohort ) - 1#
                        binMeans <- unlist( lapply( seq(1:numBins), function(x){mean( Sxy[which(XctrlSubBins==x), sxy] > ccCtrls$rxCohort[which(XctrlSubBins==x)] )} ) )#
                        currNonevent <- 1 - 2*sum(binWeights * binMeans)#
                        if(methA & sxy==1){#
                           nriEvent_A_star[s,cc] <- currEvent#
                           nriNonevent_A_star[s,cc] <- currNonevent#
                        }#
                        else {#
                           nriEvent_B_star[s,cc] <- currEvent#
                           nriNonevent_B_star[s,cc] <- currNonevent#
                        }#
                     }#
                     if(idi) {#
                        currEvent <- mean(Sxy[((nd*r+1):(nd*r+nd)), sxy]) - mean(casesRisk$rxCohort)#
                        binMeans <- unlist( lapply( seq(1:numBins), function(x){mean( Sxy[which(XctrlSubBins==x), sxy] )} ) )#
                        currNonevent <- mean(ctrlsRisk$rxCohort) - sum(binWeights * binMeans)#
                        if(methA & sxy==1){#
                           idiEvent_A_star[s,cc] <- currEvent#
                           idiNonevent_A_star[s,cc] <- currNonevent#
                        }#
                        else {#
                           idiEvent_B_star[s,cc] <- currEvent#
                           idiNonevent_B_star[s,cc] <- currNonevent#
                        }#
                     }#
                     if(tg) {#
                        currEvent <- mean(Sxy[((nd*r+1):(nd*r+nd)), sxy] > prevCohort) - mean(casesRisk$rxCohort > prevCohort)#
                        binMeans <- unlist( lapply( seq(1:numBins), function(x){mean( Sxy[which(XctrlSubBins==x), sxy] > prevCohort )} ) )#
                        currNonevent <- mean(ctrlsRisk$rxCohort > prevCohort) - sum(binWeights * binMeans)#
                        if(methA & sxy==1){#
                           tgEvent_A_star[s,cc] <- currEvent#
                           tgNonevent_A_star[s,cc] <- currNonevent#
                        }#
                        else {#
                           tgEvent_B_star[s,cc] <- currEvent#
                           tgNonevent_B_star[s,cc] <- currNonevent#
                        }#
                     }#
                     # #Figure out this issue in comproc#
                     # #   rocX <- comproc(d="cohort$dis", markers="cohort$X", roc=0.05, nobstrap=T)#
                     # #   rocXY <- comproc(d="ccSubset$dis", markers="Sxy", roc=0.05, nobstrap=T)#
                  } #sxy for loop#
               } #else#
            } #if matched#
         } #if nonparam#
         ###########
         #Bootstrap#
         ###########
         cohort_imputed <- rbind(ctrlsRisk,casesRisk)#
         for(b in 1:nBoot) {#
            print(paste(s,b))#
            resample.cohort <- sample(1:nrow(cohort_imputed), size=nrow(cohort_imputed), replace=TRUE)#
            cohort.star <- as.data.frame(cohort_imputed[resample.cohort,])#
            #Fit baseline risk model to entire cohort and get logit(P(D=1|X)) for each subject in case-ctrl subset#
            mod.star <- try(glm(dis~X,family=binomial(link="logit"),data=cohort.star),FALSE)#
            failed <- inherits(mod.star,"try-error")#
            if(failed || !mod.star$converged)#
               next#
            cohort.star$rxCohort <- mod.star$fitted.values#
            #ROC_x, AUC_x#
            cohortD.star <<- cohort.star$dis#
            #rxCohort.star <<- cohort.star$rxCohort#
            cohortX.star <<- cohort.star$X#
            rocResults <- comproc(d="cohortD.star", markers=c("cohortX.star"), roc=t, auc=T, nobstrap=T)#
            rocX.star1[b,] <- rocResults[2]#
            aucX.star1[b,] <- rocResults[1]#
            #Select nested cases#
            casesRisk.star  <- subset(cohort.star, dis==1)#
            randCases.star <- sample(seq(1:nrow(casesRisk.star)), size=nd, replace = FALSE)#
            casesRiskSub.star <- casesRisk.star[randCases.star,]#
            prevCohort.star <- nrow(casesRisk.star)/nrow(cohort.star)#
            #casesRiskSub.star <- casesRisk.star#
            #nd.star <- nrow(casesRiskSub.star)#
            #Selected nested controls#
            ctrlsRisk.star <- subset(cohort.star, dis==0)#
            if(ccSubs[cc]=="simple") {#
               #Simple Case-Control Design#
               randCtrls.star <- sample(seq(1:nrow(ctrlsRisk.star)), size=r*nd, replace = F)#
               ctrlsRiskSub.star <- ctrlsRisk.star[randCtrls.star,]#
               #ccSubset.star <- as.data.frame( rbind(ctrlsRiskSub.star, casesRiskSub.star) )#
            }#
            if(ccSubs[cc]=="freqMatch" | ccSubs[cc]=="hybrid") {#
               #Matched Case-Control Design#
               #Do matching to select controls#
               ctrlsRisk_overlap.star <- ctrlsRisk.star[ctrlsRisk.star$X >= min(casesRiskSub.star$X),]#
               binCuts.star <- cut2(ctrlsRisk_overlap.star$X, g=numBins, onlycuts=T)[2:(numBins)]#
               XctrlBins.star <- as.numeric(cut2(ctrlsRisk.star$X, cuts=binCuts.star ))#
               XcaseBins.star <- as.numeric( cut2(casesRiskSub.star$X, cuts=binCuts.star ))#
               if(is.na(mean(XctrlBins.star))) {#
                  naIndices <- which(is.na(XctrlBins.star))#
                  XctrlBins.star[naIndices] <- as.numeric( cut2(ctrlsRisk.star$X[naIndices], cuts=binCuts.star))#
               }#
               if(is.na(mean(XcaseBins.star))) {#
                  naIndices <- which(is.na(XcaseBins.star))#
                  XcaseBins.star[naIndices] <- as.numeric( cut2(casesRiskSub.star$X[naIndices], cuts=binCuts.star))#
               }#
               #Controls that are smaller than the smallest case go in bin 1, so add those in#
               nbins_cases.star <- unlist( lapply(seq(1:numBins), FUN=function(x){sum(XcaseBins.star==x)} ) )#
               #nbins_ctrls <- unlist( lapply(seq(1:numBins), FUN=function(x){sum(XctrlBins==x)} ) )#
               #nbins_ctrls_sub <- unlist( lapply(seq(1:numBins), FUN=function(x){sum(XctrlSubBins==x)} ) )#
               if(ccSubs[cc]=="freqMatch") {#
                  #Frequency-Matched Design#
                  matchedCtrls.star <- lapply( seq(1:numBins), FUN=function(x){ sample(which(XctrlBins.star==x),r*(nbins_cases.star[x]), replace=F) } )#
                  XctrlSubBins.star <- XctrlBins.star[unlist(matchedCtrls.star)]#
                  ctrlsRiskSub.star <- ctrlsRisk.star[unlist(matchedCtrls.star),]#
                  #ccSubset.star <- as.data.frame( rbind(ctrlsRiskSub.star,casesRiskSub.star) )#
               }#
               if(ccSubs[cc]=="hybrid") {#
                  #Hybrid Matched-Unmatched Design#
                  nbins_check.star <- r1*(nbins_cases.star)#
                  if(sum(floor(nbins_check.star)) < r1*nd) {#
               	     indices <- which(floor(nbins_check.star) != nbins_check.star)#
                	 pickIndicesToRoundUp <- sample(length(indices), 0.5*length(indices), replace=F)#
               	     indicesToRoundUp <- indices[pickIndicesToRoundUp]#
               	     nbins_check.star[indicesToRoundUp] <- ceiling(nbins_check.star[indicesToRoundUp])#
               	     nbins_check.star[indices[-indicesToRoundUp]] <- floor(nbins_check.star[indices[-indicesToRoundUp]])#
                  }                #
                   matchedCtrls.star <- lapply( seq(1:numBins), FUN=function(x)#
                     { sample(which(XctrlBins.star==x), nbins_check.star[x], replace=F) } )#
#                  matchedCtrls.star <- lapply( seq(1:numBins), FUN=function(x)#
#                     { sample(which(XctrlBins.star==x),r1*(nbins_cases.star[x]), replace=F) } )#
                  remainingCtrls.star <- XctrlBins.star#
                  remainingCtrls.star[unlist(matchedCtrls.star)] <- 0#
                  SRS.star <- sample(which(remainingCtrls.star!=0),(r-r1)*nd, replace=F)#
                  XctrlSubBins.star <- c(XctrlBins.star[unlist(matchedCtrls.star)], XctrlBins.star[SRS.star])#
                  ctrlsRiskSub.star <- ctrlsRisk.star[c(unlist(matchedCtrls.star),unlist(SRS.star)),]#
                  #ccSubset.star <- as.data.frame( rbind(ctrlsRiskSub.star,casesRiskSub.star) )#
               }#
            } #if(freqMatch or hybrid)#
            ##For parametric bootstrap, generate Y values for controls selected in nested case-control subset#
            #ccSubset.star$Ycohort <- ccSubset.star$Y#
            #ctrlsY.star <- modYX$coeff[1] + (modYX$coeff[2])*(ctrlsRiskSub.star$X) + sigma*(sample(modYX_resid, nrow(ctrlsRiskSub.star), replace=T))#
            #casesY.star <- modYX_cases$coeff[1] + (modYX_cases$coeff[2])*(casesRiskSub.star$X) + sigma_cases*(sample(modYX_resid_cases, nrow(casesRiskSub.star), replace=T))#
            #ccSubset.star$Y <-  c(ctrlsY.star, casesY.star)#
            ##ccSubset.star$Y <- modYX$coeff[1] + (modYX$coeff[2])*(ccSubset.star$X)#
            ##ccSubset.star$Y_param <- rnorm(n=nrow(ccSubset.star), mean=rho*(ccSubset.star$X), sd=sqrt(1-rho^2))#
            ##ccSubset.star$Y <- modYX$coeff[1] + (modYX$coeff[2])*ns(ccSubset.star$X) + #
            ##   (exp(modYX_sigma$coeff[1] + modYX_sigma$coeff[2]*ns(ccSubset.star$X)))*(sample(modYX_resid, nrow(ccSubset.star), replace=T))#
            #Impute Y values for bootstrapped cases who weren't in original phase 1 CC-subset#
            casesToImpute <- which(casesRiskSub.star$origCCsubset==0)#
            casesY.imputed <- casesRiskSub.star$Y#
            casesY.imputed[casesToImpute] <- modYX_cases$coeff[1] + (modYX_cases$coeff[2])*(casesRiskSub.star$X[casesToImpute]) + sigma_cases*(sample(modYX_resid_cases, length(casesToImpute), replace=T))#
            casesRiskSub.star$Y <- casesY.imputed      #
            #Impute Y values for bootstrapped controls who weren't in original phase 1 CC-subset#
            #Sampling from all residuals#
            #ctrlsY.imputed <- ctrlsRisk_imputed$Y#
            #ctrlsY.imputed[-origCtrls] <- modYX$coeff[1] + (modYX$coeff[2])*(ctrlsRisk$X[-origCtrls]) + sigma*(sample(modYX_resid, nrow(ctrlsRisk_imputed)-nd*r, replace=T))#
            #ctrlsRisk_imputed$Y <- ctrlsY.imputed#
            ctrlsToImpute <- which(ctrlsRiskSub.star$origCCsubset==0)#
            ctrlsY.imputed <- ctrlsRiskSub.star$Y#
            ctrlsY.imputed[ctrlsToImpute] <- NA#
            #Sampling from all residuals#
            if(ccSubs[cc]=="simple") {#
               ctrlsY.imputed[ctrlsToImpute] <- modYX$coeff[1] + (modYX$coeff[2])*(ctrlsRiskSub.star$X[ctrlsToImpute]) + sigma*(sample(modYX_resid, length(ctrlsToImpute), replace=T))#
            }   #
            #Sampling residuals within strata#
            if(ccSubs[cc]=="freqMatch" | ccSubs[cc]=="hybrid") {#
               for(i in 1:numBins) {#
                  currY <- ctrlsY.imputed[XctrlSubBins.star==i]#
                  currX <- ctrlsRiskSub.star$X[XctrlSubBins.star==i]#
                  currY[which(is.na(currY))] <- modYX$coeff[1] + (modYX$coeff[2])*(currX[which(is.na(currY))]) + #
                     sigma*(sample(modYX_resid[XctrlSubBins.star==i], sum(is.na(currY)), replace=T))#
                  ctrlsY.imputed[which(XctrlSubBins.star==i)] <- currY#
               }#
            }#
            ctrlsRiskSub.star$Y <- ctrlsY.imputed#
            ccSubset.star <- as.data.frame( rbind(ctrlsRiskSub.star,casesRiskSub.star) )#
            SxyResults.star <- getSxy(ccSubset.star, mod.star, nd, r, casesRisk.star, ctrlsRisk.star)#
            mod_cc.star <- SxyResults.star[[2]]#
            Sxy.star <- SxyResults.star[[1]]#
            ccSubset.star$SxyA <- Sxy.star[,1]#
            ccSubset.star$SxyB <- Sxy.star[,2]#
            ccCtrls.star <- subset(ccSubset.star, dis==0)#
            ccCases.star <- subset(ccSubset.star, dis==1)#
            if(semiparam) {#
               modYX.star <- lm(Y ~ X, data=ccCtrls.star)#
               #modYX.star <- lm(Ycohort ~ X, data=ccCtrls.star)#
               modYX_fitted.star <- modYX.star$coeff[1] + modYX.star$coeff[2]*(ctrlsRisk.star$X)#
               #rX_ctrlsRisk.star <- cbind(rep(1,nrow(ctrlsRisk.star)), ctrlsRisk.star$rxCohort)#
               #sigma.star <- sd(ccCtrls.star$logscr)#
               sigma.star <- sd(modYX.star$residuals)#
               modYX_resid.star <- (modYX.star$residuals)/sigma.star#
               F0.star <- ecdf(modYX_resid.star)#
               for(sxy in 1:ncol(Sxy.star)) {#
                  if(methA & sxy==1)#
                     cThreshY <- mod.star$coeff[1] + (ctrlsRisk.star$X)*(mod.star$coeff[2]) - mod_cc.star$coeff[1] - #
                        (mod_cc.star$coeff[2])*(ctrlsRisk.star$X) + mod_cc.star$coeff[3] + (mod_cc.star$coeff[4])*(ctrlsRisk.star$X)#
                  else#
                     cThreshY <- mod_cc.star$coeff[3] + mod_cc.star$coeff[4]*(ctrlsRisk.star$X) + log(nrow(casesRisk.star)/nrow(ctrlsRisk.star)) - log(nd/(r*nd))#
                  if(roc) {#
                     cThresh <- seq(max(Sxy.star[1:(nrow(ctrlsRiskSub.star)),sxy])+.001,min(Sxy.star[1:(nrow(ctrlsRiskSub.star)),sxy])-.001,by=-0.001)#
                     #cThresh <- seq(1-.001,min(Sxy[1:(r*nd),sxy])-.001,by=-0.001)#
                     #cThresh <- seq(0.75,min(Sxy[1:(r*nd),sxy])-.001,by=-0.001)#
                     ##parametric#
                     #for(k in 1:length(cThresh)) {#
                     #   cThreshY_curr <- ( log(cThresh[k]/(1-cThresh[k])) - cThreshY)/mod_cc.star$coeff[5]#
                     #   quant <- mean( pnorm(cThreshY_curr, mean=rho*ctrlsRisk.star$X, sd=sqrt(1-rho^2)) )#
                     #   currQuant <- quant#
                     #   #if(quant >= 1-t) currQuant <- quant#
                     #   if(k<length(cThresh) & quant < (1-t)) {#
                     #      if(methA & sxy==1)#
                     #         quantUsed.star1.A[b,(cc+6)] <- currQuant#
                     #      else#
                     #         quantUsed.star1.B[b,(cc+6)] <- currQuant#
                     #      break#
                     #   }#
                     #}#
                     #cFPF0.05 <- ifelse(k==1, NA, cThresh[k-1])#
                     #if(methA & sxy==1)#
                     #   quantJustAfter.star1.A[b,(cc+6)] <- quant#
                     #else#
                     #   quantJustAfter.star1.B[b,(cc+6)] <- quant#
                     ##
                     #if(methA & sxy==1)#
                     #   rocXY.star1.A[b,(cc+6)] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(Sxy.star))),sxy] <= cFPF0.05))#
                     #else#
                     #   rocXY.star1.B[b,(cc+6)] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(Sxy.star))),sxy] <= cFPF0.05))#
                     #semi-parametric, HP#
                     for(k in 1:length(cThresh)) {#
                        cThreshY_curr <- ( log(cThresh[k]/(1-cThresh[k])) - cThreshY)/mod_cc.star$coeff[5]#
                        quant <- mean( F0.star( (cThreshY_curr - modYX_fitted.star)/sigma.star) )#
                        if(quant >= 1-t) currQuant <- quant#
                        if(k<length(cThresh) & quant < (1-t)) {#
                           if(methA & sxy==1)#
                              quantUsed.star1.A[b,(cc+3)] <- currQuant#
                           else#
                              quantUsed.star1.B[b,(cc+3)] <- currQuant#
                           break#
                        }#
                     }#
                     cFPF0.05 <- ifelse(k==1, NA, cThresh[k-1])#
                     if(methA & sxy==1)#
                        quantJustAfter.star1.A[b,(cc+3)] <- quant#
                     else#
                        quantJustAfter.star1.B[b,(cc+3)] <- quant#
                     if(methA & sxy==1)#
                        rocXY.star1.A[b,(3+cc)] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(Sxy.star))),sxy] <= cFPF0.05))#
                     else#
                        rocXY.star1.B[b,(3+cc)] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(Sxy.star))),sxy] <= cFPF0.05))#
                  }#
                  if(auc) {#
                     #Sxy_auc_param <- vector(length=nd)#
                     Sxy_auc_HP <- vector(length=nd)#
                     for(nd_i in 1:nd) {#
                        cThreshY_curr <- ( log(Sxy.star[(nd_i + nrow(ctrlsRiskSub.star)),sxy]/(1-Sxy.star[(nd_i + nrow(ctrlsRiskSub.star)),sxy])) - cThreshY)/mod_cc.star$coeff[5]#
                        #Sxy_auc_param[nd_i] <- mean( pnorm(cThreshY_curr, mean=rho*ctrlsRisk.star$X, sd=sqrt(1-rho^2)) )#
                        Sxy_auc_HP[nd_i] <- mean( F0( (cThreshY_curr - modYX_fitted.star)/sigma.star ) )#
                     }#
                     if(methA & sxy==1) {#
                        aucXY.star1.A[b,(cc+3)] <- mean(Sxy_auc_HP)#
                        #aucXY.star1.A[b,(cc+6)] <- mean(Sxy_auc_param)#
                     }#
                     else {#
                        aucXY.star1.B[b,(cc+3)] <- mean(Sxy_auc_HP)#
                        #aucXY.star1.B[b,(cc+6)] <- mean(Sxy_auc_param)#
                     }#
                  }#
                  if(nri) {#
                     cThreshY_curr <- ( log(ctrlsRisk.star$rxCohort/(1-ctrlsRisk.star$rxCohort)) - cThreshY)/mod_cc.star$coeff[5]#
                     currEvent <- 2*mean( Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(ctrlsRiskSub.star)+nd)), sxy] > ccCases.star$rxCohort ) - 1#
                     #currNonevent_param <- 2*(mean( pnorm(cThreshY_curr, mean=rho*ctrlsRisk.star$X, sd=sqrt(1-rho^2)) )) - 1#
                     currNonevent_HP <- 2*(mean( F0.star( (cThreshY_curr - modYX_fitted.star)/sigma.star ) )) - 1#
                     if(methA & sxy==1){#
                        #nriEvent.star1.A[b,(cc+3)] <- nriEvent.star1.A[b,(cc+6)] <- currEvent#
                        #nriNonevent.star1.A[b,(cc+6)] <- currNonevent_param#
                        nriEvent.star1.A[b,(cc+3)] <- currEvent#
                        nriNonevent.star1.A[b,(cc+3)] <- currNonevent_HP#
                     }#
                     else {#
                        #nriEvent.star1.B[b,cc+3] <- nriEvent.star1.B[b,cc+6] <- currEvent#
                        #nriNonevent.star1.B[b,(cc+6)] <- currNonevent_param#
                        nriEvent.star1.B[b,cc+3] <- currEvent#
                        nriNonevent.star1.B[b,(cc+3)] <- currNonevent_HP#
                     }#
                  }#
                  if(idi) {#
                     cThresh <- seq(0,1,by=0.005)#
                     ##Parametric#
                     #quants <- vector(length=length(cThresh))#
                     #for(k in 1:length(cThresh)) {#
                     #   cThreshY_curr <- ( log(cThresh[k]/(1-cThresh[k])) - cThreshY)/mod_cc.star$coeff[5]#
                     #   quants[k] <- 1 - mean( pnorm(cThreshY_curr, mean=rho*ctrlsRisk.star$X, sd=sqrt(1-rho^2)) )#
                     #}#
                     #currNonevent_param <- mean(ctrlsRisk.star$rxCohort) - mean(quants)#
                     #Semi-parametric, HP#
                     quants <- vector(length=length(cThresh))#
                     for(k in 1:length(cThresh)) {#
                        cThreshY_curr <- ( log(cThresh[k]/(1-cThresh[k])) - cThreshY)/mod_cc.star$coeff[5]#
                        quants[k] <- 1 - mean( F0.star( (cThreshY_curr - modYX_fitted.star)/sigma.star ) )#
                     }#
                     currNonevent_HP <- mean(ctrlsRisk.star$rxCohort) - mean(quants)#
                     currEvent <- mean(Sxy.star[((nd*r+1):(nd*r+nd)), sxy]) - mean(casesRisk.star$rxCohort)#
                     if(methA & sxy==1){#
                        #idiEvent.star1.A[b,(cc+3)] <- idiEvent.star1.A[b,(cc+6)] <- currEvent#
                        #idiNonevent.star1.A[b,(cc+6)] <- currNonevent_param#
                        idiEvent.star1.A[b,(cc+3)] <- currEvent#
                        idiNonevent.star1.A[b,(cc+3)] <- currNonevent_HP#
                     }#
                     else {#
                        #idiEvent.star1.B[b,(cc+3)] <- idiEvent.star1.B[b,(cc+6)] <- currEvent#
                        #idiNonevent.star1.B[b,(cc+6)] <- currNonevent_param#
                        idiEvent.star1.B[b,(cc+3)] <- currEvent#
                        idiNonevent.star1.B[b,(cc+3)] <- currNonevent_HP#
                     }#
                  }#
                  if(tg) {#
                     cThreshY_curr <- ( log(prevCohort.star/(1-prevCohort.star)) - cThreshY)/mod_cc.star$coeff[5]#
                     currEvent <- mean(Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(ctrlsRiskSub.star)+nd)), sxy] > prevCohort.star) - mean(casesRisk.star$rxCohort > prevCohort.star)#
                     #currNonevent_param <- mean(ctrlsRisk.star$rxCohort > prevCohort.star) - 1 + mean( pnorm(cThreshY_curr, mean=rho*ctrlsRisk.star$X, sd=sqrt(1-rho^2)) )#
                     currNonevent_HP <- mean(ctrlsRisk.star$rxCohort > prevCohort.star) - 1 + mean( F0.star( (cThreshY_curr - modYX_fitted.star)/sigma.star ) )#
                     if(methA & sxy==1){#
                        #tgEvent.star1.A[b,(3+cc)] <- tgEvent.star1.A[b,(6+cc)] <- currEvent#
                        #tgNonevent.star1.A[b,cc+6] <- currNonevent_param#
                        tgEvent.star1.A[b,(3+cc)] <- currEvent#
                        tgNonevent.star1.A[b,(3+cc)] <- currNonevent_HP#
                     }#
                     else {#
                        #tgEvent.star1.B[b,(3+cc)] <- tgEvent.star1.B[b,(6+cc)] <- currEvent#
                        #tgNonevent.star1.B[b,(6+cc)] <- currNonevent_param#
                        tgEvent.star1.B[b,(3+cc)] <- currEvent#
                        tgNonevent.star1.B[b,(3+cc)] <- currNonevent_HP#
                     }#
                  }#
               } #sxy for loop#
            } #if semiparam#
            if(nonparam) {#
               if(ccSubs[cc]=="simple") {#
                  if(roc | auc) {#
                     ccD.star <<- ccSubset.star$dis#
                     SxyA.star <<- ccSubset.star$SxyA#
                     #SxyA <- Sxy[,1]#
                     rocResults <- comproc(d="ccD.star", markers="SxyA.star", roc=t, auc=T, nobstrap=T)#
                     aucXY.star1.A[b,cc] <- rocResults[1]#
                     rocXY.star1.A[b,cc] <- rocResults[2]#
                     SxyB.star <<- ccSubset.star$SxyB#
                     #SxyB <- Sxy[,2]#
                     rocResults <- comproc(d="ccD.star", markers="SxyB.star", roc=t, auc=T, nobstrap=T)#
                     aucXY.star1.B[b,cc] <- rocResults[1]#
                     rocXY.star1.B[b,cc] <- rocResults[2]#
                  }#
                  if(nri) {#
                     nriEvent.star1.A[b,cc] <- 2*mean( ccCases.star$SxyA > ccCases.star$rxCohort ) - 1#
                     nriNonevent.star1.A[b,cc] <- 1 - 2*mean( ccCtrls.star$SxyA > ccCtrls.star$rxCohort )#
                     nriEvent.star1.B[b,cc] <- 2*mean( ccCases.star$SxyB > ccCases.star$rxCohort )  - 1#
                     nriNonevent.star1.B[b,cc] <- 1 - 2*mean( ccCtrls.star$SxyB > ccCtrls.star$rxCohort )#
                  }#
                  if(idi) {#
                     idiEvent.star1.A[b,cc] <- mean(ccCases.star$SxyA) - mean(casesRisk.star$rxCohort)#
                     idiNonevent.star1.A[b,cc] <- mean(ctrlsRisk.star$rxCohort) - mean(ccCtrls.star$SxyA )#
                     idiEvent.star1.B[b,cc] <- mean(ccCases.star$SxyB) - mean(casesRisk.star$rxCohort)#
                     idiNonevent.star1.B[b,cc] <- mean(ctrlsRisk.star$rxCohort) - mean(ccCtrls.star$SxyB )#
                  }#
                  if(tg) {#
                     tgEvent.star1.A[b,cc] <- mean(ccCases.star$SxyA > prevCohort.star) - mean(casesRisk.star$rxCohort > prevCohort.star)#
                     tgNonevent.star1.A[b,cc] <- mean(ctrlsRisk.star$rxCohort > prevCohort.star) - mean(ccCtrls.star$SxyA > prevCohort.star)#
                     tgEvent.star1.B[b,cc] <- mean(ccCases.star$SxyB > prevCohort.star) - mean(casesRisk.star$rxCohort > prevCohort.star)#
                     tgNonevent.star1.B[b,cc] <- mean(ctrlsRisk.star$rxCohort > prevCohort.star) - mean(ccCtrls.star$SxyB > prevCohort.star)#
                  }#
               }#
               if(ccSubs[cc]=="freqMatch" | ccSubs[cc]=="hybrid") {#
                  #Calculate fpfsXY#
                  Nbins <- unlist( lapply(sort(unique(XctrlBins.star)), FUN=function(x){sum(XctrlBins.star==x)} ) )#
                  binWeights <- Nbins/nrow(ctrlsRisk.star)#
                  nbins <- unlist( lapply(sort(unique(XctrlBins.star)), FUN=function(x){sum(XctrlSubBins.star==x)} ) )#
                  if(min(nbins) == 0) {#
                     print("Empty bins")#
                     countEmptyBins[cc] <- countEmptyBins[cc] + 1#
                  }#
                  else{ #
                     for(sxy in 1:ncol(Sxy.star)) {#
                        #Estimate case and ctrl popn distns of S(X,Y) using book, ch.2#
                        if(roc) { #
                           cThresh <- seq(max(Sxy.star[1:(nrow(ctrlsRiskSub.star)),sxy])+.001,min(Sxy.star[1:(nrow(ctrlsRiskSub.star)),sxy])-.001,by=-0.001)#
                           #cThresh <- seq(max(Sxy[,sxy])+.001,min(Sxy[,sxy])-.001,by=-0.001)#
                           #cThresh <- seq(max(ccCtrls$SxyA)+.001,min(ccCtrls$SxyA)-.001,by=-0.001)#
                           binSums <- rep(0,numBins)#
                           for(k in 1:length(cThresh)) {#
                              binSums <- unlist( lapply( seq(1:numBins), #
                                 function(x){ sum(Sxy.star[which(XctrlSubBins.star==x),sxy] <= cThresh[k]) } ) )#
                              quant <- sum(binWeights * binSums/nbins)#
                              if(quant >= 1-t) currQuant <- quant#
                              if(k<length(cThresh) & quant < (1-t)) {#
                                 #quantUsed_star[b,cc] <- currQuant#
                                 #quantUsed_non[cc] <- currQuant#
                                 break#
                              }#
                           }#
                           cFPF0.05 <- ifelse(k==1, NA, cThresh[k-1])#
                           #quantJustAfter_star[b,cc] <- quant#
                           if(methA & sxy==1)#
                              rocXY.star1.A[b,cc] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(Sxy.star))),sxy] <= cFPF0.05))#
                           else#
                              rocXY.star1.B[b,cc] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy.star[(nrow(ctrlsRiskSub.star)+1):(nrow(Sxy.star)),sxy] <= cFPF0.05))#
                        }#
                        if(auc) {#
                           Sxy_auc <- vector(length=nd)#
                           for(nd_i in 1:nd) {#
                              binSums <- unlist( lapply( seq(1:numBins), function(x){ sum(Sxy.star[which(XctrlSubBins.star==x),sxy] > Sxy.star[nd_i + nrow(ctrlsRiskSub.star), sxy] ) } ) )#
                              Sxy_auc[nd_i] <- sum(binWeights * binSums/nbins)#
                           }#
                           currAuc <- 1 - mean(Sxy_auc)#
                           if(methA & sxy==1) aucXY.star1.A[b,cc] <- currAuc#
                           else aucXY.star1.B[b,cc] <- currAuc#
                        }#
                        if(nri) {#
                           currEvent <- 1 - 2*mean( Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(ctrlsRiskSub.star)+nd)), sxy] <= ccCases.star$rxCohort )#
                           #currEvent <- 2*mean( Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(ctrlsRiskSub.star)+nd)), sxy] > ccCases.star$rxCohort ) - 1#
                           binMeans <- unlist( lapply( seq(1:numBins), function(x){mean( Sxy.star[which(XctrlSubBins.star==x), sxy] > ccCtrls.star$rxCohort[which(XctrlSubBins.star==x)] )} ) )#
                           currNonevent <- 1 - 2*sum(binWeights * binMeans)#
                           if(methA & sxy==1){#
                              nriEvent.star1.A[b,cc] <- currEvent#
                              nriNonevent.star1.A[b,cc] <- currNonevent#
                           }#
                           else {#
                              nriEvent.star1.B[b,cc] <- currEvent#
                              nriNonevent.star1.B[b,cc] <- currNonevent#
                           }#
                        }#
                        if(idi) {#
                           currEvent <- mean(Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(ctrlsRiskSub.star)+nd)), sxy]) - mean(casesRisk.star$rxCohort)#
                           binMeans <- unlist( lapply( seq(1:numBins), function(x){mean( Sxy.star[which(XctrlSubBins.star==x), sxy] )} ) )#
                           currNonevent <- mean(ctrlsRisk.star$rxCohort) - sum(binWeights * binMeans)#
                           if(methA & sxy==1){#
                              idiEvent.star1.A[b,cc] <- currEvent#
                              idiNonevent.star1.A[b,cc] <- currNonevent#
                           }#
                           else {#
                              idiEvent.star1.B[b,cc] <- currEvent#
                              idiNonevent.star1.B[b,cc] <- currNonevent#
                           }#
                        }#
                        if(tg) {#
                           currEvent <- mean(Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(ctrlsRiskSub.star)+nd)), sxy] > prevCohort.star) - mean(casesRisk.star$rxCohort > prevCohort.star)#
                           binMeans <- unlist( lapply( seq(1:numBins), function(x){mean( Sxy.star[which(XctrlSubBins.star==x), sxy] > prevCohort.star )} ) )#
                           currNonevent <- mean(ctrlsRisk.star$rxCohort > prevCohort.star) - sum(binWeights * binMeans)#
                           if(methA & sxy==1){#
                              tgEvent.star1.A[b,cc] <- currEvent#
                              tgNonevent.star1.A[b,cc] <- currNonevent#
                           }#
                           else {#
                              tgEvent.star1.B[b,cc] <- currEvent#
                              tgNonevent.star1.B[b,cc] <- currNonevent#
                           }#
                        }#
                        # #Figure out this issue in comproc#
                        # #   rocX <- comproc(d="cohort$dis", markers="cohort$X", roc=0.05, nobstrap=T)#
                        # #   rocXY <- comproc(d="ccSubset$dis", markers="Sxy", roc=0.05, nobstrap=T)#
                     } #sxy for loop#
                  } #else#
               } #if matched#
            } #if nonparam#
         } #b in 1:nboot for loop#
      } #cc for loop#
      #####Bootstrap coverage#
      #rocX_bootCov[s] <-  #
      #aucX_bootCov[s,] <- vector(length=nSimul)#
      AB <- c("A","B")#
      for(ab in 1:length(AB)) {#
         for(m in 1:length(measures)) {#
            if(measures[m]=="roc" | measures[m]=="auc") {#
               submeasures <- c("X","XY","Delta")#
               currMat1 <- eval(parse(text=paste(measures[m],"X.star1",sep="")))#
               currMat2 <- eval(parse(text=paste(measures[m],"XY.star1.",AB[ab],sep="")))#
               currMat3 <- currMat2 - currMat1#
            }#
            if(measures[m]=="nri" | measures[m]=="idi" | measures[m]=="tg") {#
               submeasures <- c("Event","Nonevent","")#
               currMat1 <- eval(parse(text=paste(measures[m],"Event.star1.",AB[ab],sep="")))#
               currMat2 <- eval(parse(text=paste(measures[m],"Nonevent.star1.",AB[ab],sep="")))#
               currMat3 <- currMat2 + currMat1#
            }#
            #Coverage#
            currRes1_bootCov <- eval(parse(text=paste(measures[m],submeasures[1],"_",AB[ab],"_bootCov",sep="")))#
            currRes2_bootCov <- eval(parse(text=paste(measures[m],submeasures[2],"_",AB[ab],"_bootCov",sep="")))#
            currRes3_bootCov <- eval(parse(text=paste(measures[m],submeasures[3],"_",AB[ab],"_bootCov",sep="")))#
            currTruth1 <- eval(parse(text=paste(measures[m],"Res[1,1]",sep="")))#
            currTruth2 <- eval(parse(text=paste(measures[m],"Res[1,3]",sep="")))#
            currTruth3 <- eval(parse(text=paste(measures[m],"Res[1,5]",sep="")))#
            currRes1_bootCov[s,] <- apply(currMat1, 2, function(x) isInInterval(x, currTruth1 ))#
            currRes2_bootCov[s,] <- apply(currMat2, 2, function(x) isInInterval(x, currTruth2 ))#
            currRes3_bootCov[s,] <- apply(currMat3, 2, function(x) isInInterval(x, currTruth3 ))#
            assign(paste(measures[m],submeasures[1],"_",AB[ab],"_bootCov",sep=""), currRes1_bootCov)#
            assign(paste(measures[m],submeasures[2],"_",AB[ab],"_bootCov",sep=""), currRes2_bootCov)#
            assign(paste(measures[m],submeasures[3],"_",AB[ab],"_bootCov",sep=""), currRes3_bootCov)#
            #IQR#
            currRes1_bootIQR <- eval(parse(text=paste(measures[m],submeasures[1],"_",AB[ab],"_bootIQR",sep="")))#
            currRes2_bootIQR <- eval(parse(text=paste(measures[m],submeasures[2],"_",AB[ab],"_bootIQR",sep="")))#
            currRes3_bootIQR <- eval(parse(text=paste(measures[m],submeasures[3],"_",AB[ab],"_bootIQR",sep="")))#
            currRes1_bootIQR[s,] <- apply(currMat1, 2, function(x) diff(quantile(x, p=c(0.25,0.75), na.rm=T)))#
            currRes2_bootIQR[s,] <- apply(currMat2, 2, function(x) diff(quantile(x, p=c(0.25,0.75), na.rm=T)))#
            currRes3_bootIQR[s,] <- apply(currMat3, 2, function(x) diff(quantile(x, p=c(0.25,0.75), na.rm=T)))#
            assign(paste(measures[m],submeasures[1],"_",AB[ab],"_bootIQR",sep=""), currRes1_bootIQR)#
            assign(paste(measures[m],submeasures[2],"_",AB[ab],"_bootIQR",sep=""), currRes2_bootIQR)#
            assign(paste(measures[m],submeasures[3],"_",AB[ab],"_bootIQR",sep=""), currRes3_bootIQR)#
            #Mean#
            currRes1_bootMean <- eval(parse(text=paste(measures[m],submeasures[1],"_",AB[ab],"_bootMean",sep="")))#
            currRes2_bootMean <- eval(parse(text=paste(measures[m],submeasures[2],"_",AB[ab],"_bootMean",sep="")))#
            currRes3_bootMean <- eval(parse(text=paste(measures[m],submeasures[3],"_",AB[ab],"_bootMean",sep="")))#
            currRes1_bootMean[s,] <- apply(currMat1, 2, mean, na.rm=T )#
            currRes2_bootMean[s,] <- apply(currMat2, 2, mean, na.rm=T )#
            currRes3_bootMean[s,] <- apply(currMat3, 2, mean, na.rm=T )#
            assign(paste(measures[m],submeasures[1],"_",AB[ab],"_bootMean",sep=""), currRes1_bootMean)#
            assign(paste(measures[m],submeasures[2],"_",AB[ab],"_bootMean",sep=""), currRes2_bootMean)#
            assign(paste(measures[m],submeasures[3],"_",AB[ab],"_bootMean",sep=""), currRes3_bootMean)#
            #Std Error#
            currRes1_bootSE <- eval(parse(text=paste(measures[m],submeasures[1],"_",AB[ab],"_bootSE",sep="")))#
            currRes2_bootSE <- eval(parse(text=paste(measures[m],submeasures[2],"_",AB[ab],"_bootSE",sep="")))#
            currRes3_bootSE <- eval(parse(text=paste(measures[m],submeasures[3],"_",AB[ab],"_bootSE",sep="")))#
            currRes1_bootSE[s,] <- apply(currMat1, 2, sd, na.rm=T )#
            currRes2_bootSE[s,] <- apply(currMat2, 2, sd, na.rm=T )#
            currRes3_bootSE[s,] <- apply(currMat3, 2, sd, na.rm=T )#
            assign(paste(measures[m],submeasures[1],"_",AB[ab],"_bootSE",sep=""), currRes1_bootSE)#
            assign(paste(measures[m],submeasures[2],"_",AB[ab],"_bootSE",sep=""), currRes2_bootSE)#
            assign(paste(measures[m],submeasures[3],"_",AB[ab],"_bootSE",sep=""), currRes3_bootSE)#
         } #measures#
      } #ab#
   } #nSimul for loop#
   #rocBootResIQR <- aucBootResIQR <- tgBootResIQR <- nriBootResIQR <- idiBootResIQR <- matrix(nrow=12, ncol=9)#
   for(m in 1:length(measures)) {#
      if(measures[m]=="roc" | measures[m]=="auc") {#
         submeasures <- c("X","XY","Delta")#
         currMat1A_sim <- eval(parse(text=paste(measures[m],submeasures[1],"_A_star",sep="")))#
         currMat1A_sim <- currMat1B_sim <- matrix(rep(currMat1A_sim[,1], ncol(currMat1A_sim)), nrow=nrow(currMat1A_sim))#
         currMat2A_sim <- eval(parse(text=paste(measures[m],submeasures[2],"_A_star",sep="")))#
         currMat2B_sim <- eval(parse(text=paste(measures[m],submeasures[2],"_B_star",sep="")))#
         currMat3A_sim <- currMat2A_sim - currMat1A_sim#
         currMat3B_sim <- currMat2B_sim - currMat1B_sim#
         currMat1A_bootIQR <- currMat1B_bootIQR <- eval(parse(text=paste(measures[m],submeasures[1],"_A_bootIQR",sep="")))#
         currMat1A_bootCov <- currMat1B_bootCov <- eval(parse(text=paste(measures[m],submeasures[1],"_A_bootCov",sep="")))#
      }#
      if(measures[m]=="nri" | measures[m]=="idi" | measures[m]=="tg") {#
         submeasures <- c("Event","Nonevent","")#
         currMat1A_sim <- eval(parse(text=paste(measures[m],submeasures[1],"_A_star",sep="")))#
         currMat1B_sim <- eval(parse(text=paste(measures[m],submeasures[1],"_B_star",sep="")))#
         currMat2A_sim <- eval(parse(text=paste(measures[m],submeasures[2],"_A_star",sep="")))#
         currMat2B_sim <- eval(parse(text=paste(measures[m],submeasures[2],"_B_star",sep="")))#
         currMat3A_sim <- currMat2A_sim + currMat1A_sim#
         currMat3B_sim <- currMat2B_sim + currMat1B_sim#
         currMat1A_bootIQR <- eval(parse(text=paste(measures[m],submeasures[1],"_A_bootIQR",sep="")))#
         currMat1B_bootIQR <- eval(parse(text=paste(measures[m],submeasures[1],"_B_bootIQR",sep="")))#
         currMat1A_bootCov <- eval(parse(text=paste(measures[m],submeasures[1],"_A_bootCov",sep="")))#
         currMat1B_bootCov <- eval(parse(text=paste(measures[m],submeasures[1],"_B_bootCov",sep="")))#
      }#
      currMat2A_bootIQR <- eval(parse(text=paste(measures[m],submeasures[2],"_A_bootIQR",sep="")))#
      currMat2B_bootIQR <- eval(parse(text=paste(measures[m],submeasures[2],"_B_bootIQR",sep="")))#
      currMat3A_bootIQR <- eval(parse(text=paste(measures[m],submeasures[3],"_A_bootIQR",sep="")))#
      currMat3B_bootIQR <- eval(parse(text=paste(measures[m],submeasures[3],"_B_bootIQR",sep="")))#
      currMat2A_bootCov <- eval(parse(text=paste(measures[m],submeasures[2],"_A_bootCov",sep="")))#
      currMat2B_bootCov <- eval(parse(text=paste(measures[m],submeasures[2],"_B_bootCov",sep="")))#
      currMat3A_bootCov <- eval(parse(text=paste(measures[m],submeasures[3],"_A_bootCov",sep="")))#
      currMat3B_bootCov <- eval(parse(text=paste(measures[m],submeasures[3],"_B_bootCov",sep="")))#
      ###Bootstrap IQR Results#
      currBootResIQR <- matrix(nrow=12, ncol=9)#
      currBootResIQR[1,] <- apply(currMat1A_sim, 2, function(x) diff(quantile(x, p=c(0.25,0.75), na.rm=T)))#
      currBootResIQR[3,] <- apply(currMat1B_sim, 2, function(x) diff(quantile(x, p=c(0.25,0.75), na.rm=T)))#
      currBootResIQR[5,] <- apply(currMat2A_sim, 2, function(x) diff(quantile(x, p=c(0.25,0.75), na.rm=T)))#
      currBootResIQR[7,] <- apply(currMat2B_sim, 2, function(x) diff(quantile(x, p=c(0.25,0.75), na.rm=T)))#
      currBootResIQR[9,] <- apply(currMat3A_sim, 2, function(x) diff(quantile(x, p=c(0.25,0.75), na.rm=T)))#
      currBootResIQR[11,] <- apply(currMat3B_sim, 2, function(x) diff(quantile(x, p=c(0.25,0.75), na.rm=T)))#
      currBootResIQR[2,] <- apply(currMat1A_bootIQR, 2, mean, na.rm=T)#
      currBootResIQR[4,] <- apply(currMat1B_bootIQR, 2, mean, na.rm=T)#
      currBootResIQR[6,] <- apply(currMat2A_bootIQR, 2, mean, na.rm=T)#
      currBootResIQR[8,] <- apply(currMat2B_bootIQR, 2, mean, na.rm=T)#
      currBootResIQR[10,] <- apply(currMat3A_bootIQR, 2, mean, na.rm=T)#
      currBootResIQR[12,] <- apply(currMat3B_bootIQR, 2, mean, na.rm=T)#
      rownamesHalf <- c("_sim_A", "_boot_A", "_sim_B","_boot_B")#
      rownames(currBootResIQR) <- as.vector(sapply(submeasures, function(x) paste(measures[m],x,rownamesHalf,sep="") ))#
      colnames(currBootResIQR) <- c("unmatch_non","freq_non","hybrid_non","unmatch_semi","freq_semi","hybrid_semi","unmatch_param","freq_param","hybrid_param")#
      assign(paste(measures[m],"BootResIQR",sep=""), currBootResIQR)#
      ###Bootstrap Coverage Results#
      currBootResCov <- matrix(nrow=6, ncol=9)#
      currBootResCov[1,] <- apply(currMat1A_bootCov, 2, mean, na.rm=T)#
      currBootResCov[2,] <- apply(currMat1B_bootCov, 2, mean, na.rm=T)#
      currBootResCov[3,] <- apply(currMat2A_bootCov, 2, mean, na.rm=T)#
      currBootResCov[4,] <- apply(currMat2B_bootCov, 2, mean, na.rm=T)#
      currBootResCov[5,] <- apply(currMat3A_bootCov, 2, mean, na.rm=T)#
      currBootResCov[6,] <- apply(currMat3B_bootCov, 2, mean, na.rm=T)#
      rownamesHalf <- c("_boot_A", "_boot_B")#
      rownames(currBootResCov) <- as.vector(sapply(submeasures, function(x) paste(measures[m],x,rownamesHalf,sep="") ))#
      colnames(currBootResCov) <- c("unmatch_non","freq_non","hybrid_non","unmatch_semi","freq_semi","hybrid_semi","unmatch_param","freq_param","hybrid_param")#
      assign(paste(measures[m],"BootResCov",sep=""), currBootResCov)#
   }
rocBootResIQR
aucBootResIQR
tgBootResIQR
nriBootResIQR
idiBootResIQR
rocBootResCov
aucBootResCov
tgBootResCov
nriBootResCov
idiBootResCov
nSimul=100#
nBoot=100#
N=5000#
nd=100#
r=2#
rho=0.5
mbnp=T#
t=0.1#
numBins=4#
r1=0.5*r#
mu_x = 0#
mu_y = 0#
sd_x = 1#
sd_y = 1#
mu_x_db=0#
sd_x_db=1#
sd_x_d=1#
auc_x=0.7#
mu_y_db=0#
sd_y_db=1#
sd_y_d=1#
auc_y=0.7#
prev=0.1#
simpleDes=T#
freqMatchedDes=T#
hybridDes=T#
methA=T#
methB=T#
roc=T#
auc=T#
nri=T#
idi=T#
tg=T#
hr=F#
ru=F#
pnf=F#
nonparam=T#
semiparam=T#
riskThresh=0.2#
PNFtpr=0.8
measures <- c("roc","auc","nri","idi","tg")
rm(list=ls())
library(MASS)#
library(Hmisc)#
library(xtable)#
#source("C:\\Users\\aasthaa\\My Dropbox\\RA_Hutch\\2009_11_13_fromDaryl\\roccurve.r")#
#source("C:\\Users\\aasthaa\\My Dropbox\\RA_Hutch\\2009_11_13_fromDaryl\\comproc_noPrint.r")#
#source("C:\\Users\\aasthaa\\My Dropbox\\RA_Hutch\\2009_11_13_fromDaryl\\hidden.r")#
source("/Users/aasthaa/Dropbox/RA_Hutch/2009_11_13_fromDaryl/roccurve.r")#
source("/Users/aasthaa/Dropbox/RA_Hutch/2009_11_13_fromDaryl/comproc_noPrint.r")#
source("/Users/aasthaa/Dropbox/RA_Hutch/2009_11_13_fromDaryl/hidden.r")#
#source("C:\\Documents and Settings\\abansal\\My Documents\\My Dropbox\\RA_Hutch\\2009_11_13_fromDaryl\\roccurve.r")#
#source("C:\\Documents and Settings\\abansal\\My Documents\\My Dropbox\\RA_Hutch\\2009_11_13_fromDaryl\\comproc_noPrint.r")#
#source("C:\\Documents and Settings\\abansal\\My Documents\\My Dropbox\\RA_Hutch\\2009_11_13_fromDaryl\\hidden.r")#
#Non-parametric, unmatched#
calcNRI <- function(casesXY, casesX, ctrlsXY, ctrlsX) {#
   nriEvent <- mean(casesXY > casesX) - mean(casesXY <= casesX)#
   nriNonevent <- mean(ctrlsXY <= ctrlsX) - mean(ctrlsXY > ctrlsX)#
   return( c(nriEvent, nriNonevent ))#
}#
calcIDI <- function(casesXY, casesX, ctrlsXY, ctrlsX) {#
   idiEvent <- mean(casesXY) - mean(casesX)#
   idiNonevent <- mean(ctrlsX) - mean(ctrlsXY)#
   return( c(idiEvent, idiNonevent) )#
}#
calcTG <- function(currPrev, casesXY, casesX, ctrlsXY, ctrlsX) {#
   fprX <- mean(ctrlsX > currPrev)#
   fprXY <- mean(ctrlsXY > currPrev)#
   tprX <- mean(casesX > currPrev)#
   tprXY <- mean(casesXY > currPrev)#
   tgEvent <- tprXY-tprX#
   tgNonevent <- fprX-fprXY#
   return( c(tgEvent, tgNonevent) )#
}#
#Semi-parametric and Parametric#
calcNRI_semi_match <- function(casesXY, casesX, ctrlsXY, ctrlsX) {#
   nriEvent <- mean(casesXY > casesX) - mean(casesXY <= casesX)#
   nriNonevent <- mean(ctrlsXY <= ctrlsX) - mean(ctrlsXY > ctrlsX)#
   return( c(nriEvent, nriNonevent ))#
}#
getSxy <- function(currCCSubset, currMod, curr_nd, curr_r, currCasesRisk, currCtrlsRisk) {#
   #Get estimates of P(D=1|X) from each subject in cohort#
   logitPx_cohort <- currMod$coeff[1] + (currCCSubset$X)*currMod$coeff[2]#
   currCCSubset$rx <- exp(logitPx_cohort)/(1+exp(logitPx_cohort))#
   #Fit DLR regression model to case-control data#
   #Fit 2 logistic regression models to case-ctrl subset, using trick in Appendix A of Gu & Pepe (2008)#
   ccSubsetRep <- NULL#
   V <- cbind(currCCSubset$X, currCCSubset$Y)#
   for( modFitRep in 1:(dim(currCCSubset)[1]) ) {#
      ccSubsetRep <- rbind(ccSubsetRep, c(currCCSubset$dis[modFitRep], 0,0,1,V[modFitRep,]))#
      ccSubsetRep <- rbind(ccSubsetRep, c(currCCSubset$dis[modFitRep], 1,currCCSubset$X[modFitRep],0,0,0))#
   }#
   ccSubsetRep <- as.data.frame(ccSubsetRep)#
   names(ccSubsetRep) <- c("dis","z1","z2","z3","z4","z5")#
   mod_cc <- glm(dis~z1+z2+z3+z4+z5-1, family=binomial(link="logit"), data=ccSubsetRep)#
   logitPx_cc <- mod_cc$coeff[1] + mod_cc$coeff[2]*(currCCSubset$X)#
   logitPxy_cc <- mod_cc$coeff[3] + mod_cc$coeff[4]*(currCCSubset$X) + mod_cc$coeff[5]*(currCCSubset$Y)#
   #Calculate logDLRx(Y)#
   logDLRxY <- logitPxy_cc - logitPx_cc#
   #Calculate logit(P(D=1|X,Y)) = S(X,Y) for each subject in case-ctrl subset#
   ##Method A#
   logitSxy <- logitPx_cohort + logDLRxY#
   Sxy <- exp(logitSxy)/(1+exp(logitSxy))#
   ##Method B#
   #logitSxy <- logitPxy_cc - log(nd/(r*nd)) + log(nrow(casesRisk)/nrow(ctrlsRisk))#
   logitSxy <- logitPxy_cc - log(curr_nd/(curr_r*curr_nd)) + log(nrow(currCasesRisk)/nrow(currCtrlsRisk))#
   Sxy <- cbind(Sxy, exp(logitSxy)/(1+exp(logitSxy)))#
   return(list(Sxy, mod_cc))#
}#
isInInterval <- function(currVec, currTruth) {#
   currInt <- quantile(currVec, p=c(0.025,0.975), na.rm=T)#
   return(currTruth > currInt[1] & currTruth < currInt[2])#
}
nSimul=100#
nBoot=100#
N=5000#
nd=100#
r=2#
rho=0.5#
mbnp=T#
t=0.1#
numBins=4#
r1=0.5*r#
mu_x = 0#
mu_y = 0#
sd_x = 1#
sd_y = 1#
mu_x_db=0#
sd_x_db=1#
sd_x_d=1#
auc_x=0.7#
mu_y_db=0#
sd_y_db=1#
sd_y_d=1#
auc_y=0.7#
prev=0.1#
simpleDes=T#
freqMatchedDes=T#
hybridDes=T#
methA=T#
methB=T#
roc=T#
auc=T#
nri=T#
idi=T#
tg=T#
hr=F#
ru=F#
pnf=F#
nonparam=T#
semiparam=T#
riskThresh=0.2#
PNFtpr=0.8
measures <- c("roc","auc","nri","idi","tg")
set.seed(4)
PopnN <- 1000000
rocRes <- aucRes <- nriRes <- idiRes <- tgRes <- ruRes <- pnfRes <- rocinvRes <- hrcRes <- hrnRes <- bRes <- as.data.frame(matrix(nrow=1,ncol=6))#
   names(rocRes) <- names(aucRes) <- names(ruRes) <- names(pnfRes) <- names(rocinvRes) <- #
      names(hrcRes) <- names(hrnRes) <- c("X","sd_X","XY","sd_XY","delta","sd_delta")#
   names(nriRes) <- names(idiRes) <- names(tgRes) <- names(bRes) <- c("Event","sd_Event","Nonevent","sd_Nonevent","sum","sd_sum")#
   rownames(rocRes) <- rownames(aucRes) <- rownames(nriRes) <- rownames(idiRes) <- rownames(tgRes) <-#
      rownames(pnfRes) <- rownames(ruRes) <- rownames(rocinvRes) <- rownames(hrcRes) <- rownames(hrnRes) <- rownames(bRes) <- "truth"#
   ccSubs <- ifelse(simpleDes, "simple", NULL)#
   if(freqMatchedDes)#
      ccSubs <- c(ccSubs,"freqMatch")#
   if(hybridDes)#
      ccSubs <- c(ccSubs,"hybrid")#
   countEmptyBins <- matrix(0, nrow=2, ncol=length(ccSubs))  #methods A and B by designs#
   #countNAcThresh <- NULL#
   quantUsed <- matrix(nrow=2,ncol=length(ccSubs)) #methods by designs#
   quantJustAfter <- matrix(nrow=2,ncol=length(ccSubs)) #methods by designs#
   if(!mbnp) {#
      popnCohort <- mvrnorm(n=PopnN,mu=c(mu_x,mu_y),Sigma=matrix(c(sd_x,rho,rho,sd_y),2,2))#
      #X <- popnCohort[,1]#
      X <<- popnCohort[,1]#
      Y <- popnCohort[,2]#
      alpha <- log(risk00/(1-risk00))#
      betaX <- (log(risk01_x/(1-risk01_x)) - alpha)#
      betaY <- (log(risk01_y/(1-risk01_y)) - alpha)#
      betaXx <- betaX*X#
      betaYy <- betaY*Y#
      linExp <- alpha + betaXx + betaYy#
      P <- exp(linExp)/(exp(linExp) + 1)#
      dis <<- rbinom(n=PopnN, size=1, prob=P)#
      #Calculate true risk(X)#
      muCond_yx <- rho*X  #vector for all x's#
      riskX_truth <<- sapply(1:PopnN, function(x){#
         Y_x <- rnorm(n=PopnN, mean=rho*muCond_yx[x], sd=sqrt(1-rho^2))#
         linExp_X <- alpha + betaXx[x] + betaY*Y_x#
         P_x <- exp(linExp_X)/(exp(linExp_X) + 1)#
         mean(P_x)#
      } )#
      riskXY_truth <<- P#
   }#
   if(mbnp) {#
      mu_x_d <- (sqrt(2))*qnorm(auc_x)#
      mu_y_d <- (sqrt(2))*qnorm(auc_y)#
      ctrls <- mvrnorm(n=PopnN*(1-prev),mu=c(mu_x_db,mu_y_db),Sigma=matrix(c(sd_x_db,rho,rho,sd_y_db),2,2))#
      cases <- mvrnorm(n=PopnN*prev,mu=c(mu_x_d,mu_y_d),Sigma=matrix(c(1,rho,rho,1),2,2))#
      X <<- c(ctrls[,1],cases[,1])#
      Y <- c(ctrls[,2],cases[,2])#
      dis <<- c(rep(0,PopnN*(1-prev)),rep(1,PopnN*prev))#
      #dis <- c(rep(0,PopnN*(1-prev)),rep(1,PopnN*prev))#
      alpha0 <- -0.5/(1-rho^2)*(mu_x_d^2 - 2*rho*mu_x_d*mu_y_d + mu_y_d^2) + log(prev/(1-prev))#
      alpha1 <- (mu_x_d - rho*mu_y_d)/(1-rho^2)#
      alpha2 <- (mu_y_d - rho*mu_x_d)/(1-rho^2)#
      riskXY_truth_logit <- alpha0 + alpha1*X + alpha2*Y#
      riskXY_truth <<- exp(riskXY_truth_logit)/(exp(riskXY_truth_logit) + 1)#
      alpha0_x <- -0.5*mu_x_d^2 + log(prev/(1-prev))#
      alpha1_x <- mu_x_d#
      riskX_truth_logit <- alpha0_x + alpha1_x*X#
      riskX_truth <<- exp(riskX_truth_logit)/(exp(riskX_truth_logit)+1)#
   }#
   dataset <- as.data.frame(cbind(X,Y,dis,riskX_truth,riskXY_truth) )#
   #Large Sample estimates#
   modX <- glm(dis~X,family=binomial(link="logit"),data=dataset)#
   modXY <- glm(dis~X+Y,family=binomial(link="logit"),data=dataset)#
   dataset$riskX_est <- modX$fitted.values#
   dataset$riskXY_est <- modXY$fitted.values#
   riskX_est <<- modX$fitted.values#
   riskXY_est <<- modXY$fitted.values
Calculate truth#
   if(roc | auc) {#
      #rocResults <- comproc(d="dis", markers=c("X","XYcombo"), roc=t, auc=T, nobstrap=T)#
      if(!mbnp) {#
         rocResults <- comproc(d="dis", markers=c("X","riskXY_truth"), roc=t, auc=T, nobstrap=T)#
         aucRes[1,] <- c(rocResults[1],NA,rocResults[2],NA,rocResults[3],NA)#
         rocRes[1,] <- c(rocResults[4],NA,rocResults[5],NA,rocResults[6],NA)#
      }#
      if(mbnp) {#
         rocX <- pnorm( (mu_x_d + qnorm(t))/sd_x_d )#
         rocXY <- pnorm( (mu_x_d + alpha2/alpha1*(mu_y_d))/sqrt(1 + (alpha2/alpha1)^2 + 2*alpha2/alpha1*rho) + qnorm(t) )#
         aucX <- pnorm( mu_x_d/sqrt(2) )#
         aucXY <- pnorm( (mu_x_d + alpha2/alpha1*(mu_y_d))/sqrt(2*(1+ (alpha2/alpha1)^2 + 2*alpha2/alpha1*rho)) )#
         aucRes[1,] <- c(aucX,NA,aucXY,NA,(aucXY-aucX),NA)#
         rocRes[1,] <- c(rocX,NA,rocXY,NA,(rocXY-rocX),NA)#
         #aucRes[1,] <- c(aucX,NA,NA,aucXY,NA,NA,(aucXY-aucX),NA,NA)#
      }#
      #rocResults <- comproc(d="dis", markers=c("X","riskXY_est"), roc=t, auc=T, nobstrap=T)#
      #aucRes <- rbind(aucRes, c(rocResults[1],NA,rocResults[2],NA,rocResults[3],NA) )#
      #rocRes <- rbind(rocRes, c(rocResults[4],NA,rocResults[5],NA,rocResults[6],NA) )#
      ##aucRes <- rbind(aucRes, c(rocResults[1],NA,NA,rocResults[2],NA,NA,rocResults[3],NA,NA) )#
   }#
   if(pnf) {#
      rocinvX <- pnorm( (mu_x_db - mu_x_d + sd_x_d*qnorm(PNFtpr) ) / sd_x_db )#
      rocinvXY <- pnorm( (0 - mu_x_d - alpha2/alpha1*(mu_y_d) + sqrt(1 + (alpha2/alpha1)^2 + 2*alpha2/alpha1*rho)*qnorm(PNFtpr) ) /#
         sqrt(1 + (alpha2/alpha1)^2 + 2*alpha2/alpha1*rho) )#
      rocinvRes[1,] <- c( rocinvX, NA, rocinvXY, NA, rocinvX-rocinvXY, NA)#
      pnfRes[1,] <- c( (1-prev)*rocinvX, NA, (1-prev)*rocinvXY, NA, (1-prev)*(rocinvX-rocinvXY), NA)#
      #rocResults <- comproc(d="dis", markers=c("X","riskXY_truth"), rocinv=PNFtpr, nobstrap=T)#
      #rocinvRes <- rbind(rocinvRes, c(rocResults[1], NA, rocResults[2], NA, -rocResults[3], NA) )#
      #pnfRes <- rbind(pnfRes, c((1-prev)*rocResults[1], NA, (1-prev)*rocResults[2], NA, (1-prev)*(-rocResults[3]), NA) )#
      #rocResults <- comproc(d="dis", markers=c("X","riskXY_est"), rocinv=PNFtpr, nobstrap=T)#
      #rocinvRes <- rbind(rocinvRes, c(rocResults[1], NA, rocResults[2], NA, -rocResults[3], NA) )#
      #pnfRes <- rbind(pnfRes, c((1-prev)*rocResults[1], NA, (1-prev)*rocResults[2], NA, (1-prev)*(-rocResults[3]), NA) )#
   }#
   if(hr | ru) {#
      #This is for X, we need riskX#
      #tprX <- pnorm( (mu_x_d - riskThresh)/sd_x_d )#
      #fprX <- pnorm( (mu_x_db - riskThresh)/sd_x_db )#
      #tprXY <- pnorm( (mu_x_d + alpha2/alpha1*(mu_y_d) - riskThresh)/sqrt(1 + (alpha2/alpha1)^2 + 2*alpha2/alpha1*rho) )#
      #fprXY <- pnorm( -riskThresh/sqrt(1 + (alpha2/alpha1)^2 + 2*alpha2/alpha1*rho) )#
      #Simple way, but have variability from X and Y#
      #tprX <- mean(riskX_truth[dis==1] > riskThresh)#
      #fprX <- mean(riskX_truth[dis==0] > riskThresh)#
      #tprXY <- mean(riskXY_truth[dis==1] > riskThresh)#
      #fprXY <- mean(riskXY_truth[dis==0] > riskThresh)#
      #bEvent <- mean(cases$riskXY_truth > riskThresh) - mean(cases$riskX_truth > riskThresh)#
      #bNonevent <- mean(ctrls$riskXY_truth > riskThresh) - mean(ctrls$riskX_truth > riskThresh)#
      logitRiskThresh <- log(riskThresh/(1-riskThresh))#
      tprX <- pnorm( (alpha0_x + alpha1_x*mu_x_d - logitRiskThresh)/alpha1_x*sd_x_d )#
      fprX <- pnorm( (alpha0_x + alpha1_x*mu_x_db - logitRiskThresh)/alpha1_x*sd_x_db )#
      tprXY <- pnorm( (alpha0 + alpha1*mu_x_d + alpha2*mu_y_d - logitRiskThresh)/sqrt(alpha1^2 + alpha2^2 + 2*alpha1*alpha2*rho) )#
      fprXY <- pnorm( (alpha0 + alpha1*mu_x_db + alpha2*mu_y_db - logitRiskThresh)/sqrt(alpha1^2 + alpha2^2 + 2*alpha1*alpha2*rho) )#
      hrcRes[1,] <- c( tprX, NA, tprXY, NA, tprXY-tprX, NA )#
      hrnRes[1,] <- c( fprX, NA, fprXY, NA, fprX-fprXY, NA )#
      ruX <- tprX - riskThresh/(1-riskThresh) * (1-prev)/prev * fprX#
      ruXY <- tprXY - riskThresh/(1-riskThresh) * (1-prev)/prev * fprXY#
      ruRes[1,] <- c( ruX, NA, ruXY, NA, ruXY-ruX, NA ) #
      bEvent <- tprXY-tprX#
      bNonevent <- fprX-fprXY#
      bRes[1,] <- c(bEvent, NA, bNonevent, NA, bEvent+bNonevent, NA)#
   }
if(nri | idi | tg) {#
      cases <- subset(dataset, dis==1)#
      ctrls <- subset(dataset, dis==0)#
      if(nri) {#
         nriEvent <- mean(cases$riskXY_truth > cases$riskX_truth) - mean(cases$riskXY_truth <= cases$riskX_truth)#
         nriNonevent <- mean(ctrls$riskXY_truth <= ctrls$riskX_truth) - mean(ctrls$riskXY_truth > ctrls$riskX_truth)#
         nriRes[1,] <- c(nriEvent,NA,nriNonevent,NA,(nriEvent+nriNonevent),NA)#
         #nriEvent <- mean(cases$riskXY_est > cases$riskX_est) - mean(cases$riskXY_est <= cases$riskX_est)#
         #nriNonevent <- mean(ctrls$riskXY_est <= ctrls$riskX_est) - mean(ctrls$riskXY_est > ctrls$riskX_est)#
         #nriRes <- rbind(nriRes, c(nriEvent,NA,nriNonevent,NA,(nriEvent+nriNonevent),NA))#
      }#
      if(idi) {#
         idiEvent <- mean(cases$riskXY_truth) - mean(cases$riskX_truth)#
         idiNonevent <- mean(ctrls$riskX_truth) - mean(ctrls$riskXY_truth)#
         idiRes[1,] <- c(idiEvent,NA,idiNonevent,NA,(idiEvent+idiNonevent),NA)#
         #idiEvent <- mean(cases$riskXY_est) - mean(cases$riskX_est)#
         #idiNonevent <- mean(ctrls$riskX_est) - mean(ctrls$riskXY_est)#
         #idiRes <- rbind(idiRes, c(idiEvent,NA,idiNonevent,NA,(idiEvent+idiNonevent),NA) )#
      }#
      if(tg) {#
         prevPop <- nrow(cases)/PopnN#
         logitPrev <- log(prevPop/(1-prevPop))#
         fprX <- pnorm( (alpha0_x + alpha1_x*mu_x_db - logitPrev)/alpha1_x*sd_x_db )#
         fprXY <- pnorm( (alpha0 + alpha1*mu_x_db + alpha2*mu_y_db - logitPrev)/sqrt(alpha1^2 + alpha2^2 + 2*alpha1*alpha2*rho) )#
         tprX <- pnorm( (alpha0_x + alpha1_x*mu_x_d - logitPrev)/alpha1_x*sd_x_d )#
         tprXY <- pnorm( (alpha0 + alpha1*mu_x_d + alpha2*mu_y_d - logitPrev)/sqrt(alpha1^2 + alpha2^2 + 2*alpha1*alpha2*rho) )#
         tgEvent <- tprXY-tprX#
         tgNonevent <- fprX-fprXY#
         tgRes[1,] <- c(tgEvent,NA,tgNonevent,NA,tgEvent+tgNonevent,NA)#
         #fprX <- mean(ctrls$riskX_truth > prevPop)#
         #fprXY <- mean(ctrls$riskXY_truth > prevPop)#
         #tprX <- mean(cases$riskX_truth > prevPop)#
         #tprXY <- mean(cases$riskXY_truth > prevPop)#
         #bX <- mean(cases$riskX_truth > riskThresh) - mean(ctrls$riskX_truth > riskThresh)#
         #bXY <- mean(cases$riskXY_truth > riskThresh) - mean(ctrls$riskXY_truth > riskThresh)#
         #bRes[1,] <- c(bX, NA, bXY, NA, bXY - bX, NA)#
         ##Large Sample#
         #fprX <- mean(ctrls$riskX_est > prevPop)#
         #fprXY <- mean(ctrls$riskXY_est > prevPop)#
         #tprX <- mean(cases$riskX_est > prevPop)#
         #tprXY <- mean(cases$riskXY_est > prevPop)#
         #tgEvent <- tprXY-tprX#
         #tgNonevent <- fprX-fprXY#
         #tgRes <- rbind(tgRes, c(tgEvent,NA,tgNonevent,NA,tgEvent+tgNonevent,NA))#
      }#
   }
ruX_star <- vector(length=nSimul)#
   pnfX_star <- vector(length=nSimul)#
   rocinvX_star <- vector(length=nSimul)#
   hrcX_star <- vector(length=nSimul)#
   hrnX_star <- vector(length=nSimul)#
   #Nonparametric Estimates#
#   rocXY_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
#   rocXY_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
#   aucXY_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
#   aucXY_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   rocX_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocX_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   #ruXY_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #ruXY_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #pnfXY_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #pnfXY_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #rocinvXY_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #rocinvXY_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #hrcXY_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #hrcXY_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #hrnXY_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #hrnXY_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #bEvent_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #bNonevent_A_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #bEvent_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   #bNonevent_B_star <- matrix(nrow=nSimul, ncol=length(ccSubs))#
   quantUsed_star <- quantUsed_semi_HP_star <- quantUsed_param_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   quantJustAfter_star <- quantJustAfter_semi_HP_star <- quantJustAfter_param_star <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   #####Bootstrap coverage#
   #rocX_bootCov <- vector(length=nSimul)#
   #aucX_bootCov <- vector(length=nSimul)#
   rocX_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocDelta_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocX_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocDelta_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucDelta_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucDelta_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nri_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nri_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idi_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idi_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tg_A_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tg_B_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   #quantUsed_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   #quantJustAfter_bootCov <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   #####Bootstrap IQR#
   #rocX_bootIQR <- vector(length=nSimul)#
   #aucX_bootIQR <- vector(length=nSimul)#
   rocX_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocDelta_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocX_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocDelta_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucDelta_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucDelta_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nri_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nri_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idi_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idi_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tg_A_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tg_B_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   #quantUsed_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   #quantJustAfter_bootIQR <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   #####Bootstrap Mean#
   rocX_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocDelta_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocX_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocDelta_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucDelta_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucDelta_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nri_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nri_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idi_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idi_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tg_A_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tg_B_bootMean <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   #####Bootstrap Std Error#
   rocX_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocDelta_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocX_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocXY_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   rocDelta_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucDelta_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucX_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucXY_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   aucDelta_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nri_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriEvent_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nriNonevent_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   nri_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idi_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiEvent_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idiNonevent_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   idi_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tg_A_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgEvent_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tgNonevent_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)#
   tg_B_bootSE <- matrix(nrow=nSimul, ncol=length(ccSubs)*3)
for(s in 1:nSimul) {#
      print(paste("s:",s))#
      rocX.star1 <- aucX.star1 <- rocXY.star1.A <- aucXY.star1.A <- nriEvent.star1.A <- nriNonevent.star1.A <- #
         idiEvent.star1.A <- idiNonevent.star1.A <- tgEvent.star1.A <- tgNonevent.star1.A <- #
         rocX.star1 <- aucX.star1 <- rocXY.star1.B <- aucXY.star1.B <- nriEvent.star1.B <- nriNonevent.star1.B <- #
         idiEvent.star1.B <- idiNonevent.star1.B <- tgEvent.star1.B <- tgNonevent.star1.B <- #
         quantUsed.star1.A <- quantUsed.star1.B <- quantJustAfter.star1.A <- quantJustAfter.star1.B <-#
         as.data.frame(matrix(ncol=length(ccSubs)*3, nrow=nBoot))#
      names(rocX.star1) <- names(aucX.star1) <- names(rocXY.star1.A) <- names(aucXY.star1.A) <- names(nriEvent.star1.A) <- names(nriNonevent.star1.A) <- #
      names(idiEvent.star1.A) <- names(idiNonevent.star1.A) <- names(tgEvent.star1.A) <- names(tgNonevent.star1.A) <- #
      names(rocXY.star1.B) <- names(aucXY.star1.B) <- names(nriEvent.star1.B) <- names(nriNonevent.star1.B) <- #
      names(idiEvent.star1.B) <- names(idiNonevent.star1.B) <- names(tgEvent.star1.B) <- names(tgNonevent.star1.B) <- #
      names(quantUsed.star1.A) <- names(quantUsed.star1.B) <- names(quantJustAfter.star1.A) <- names(quantJustAfter.star1.B) <-#
      c("unmatch_non","freq_non","hybrid_non","unmatch_semi","freq_semi","hybrid_semi","unmatch_param","freq_param","hybrid_param")#
      randCohort <- sample(seq(1:PopnN), size=N, replace = FALSE)#
      cohort <- as.data.frame(dataset[randCohort,])#
      #names(cohort) <- c("X","Y","dis")#
      cohortD <<- cohort$dis#
      cohortX <<- cohort$X#
      rocResults <- comproc(d="cohortD", markers="cohortX", roc=t, auc=T, nobstrap=T)#
      aucX_A_star[s,] <- aucX_B_star[s,] <- rocResults[1]#
      rocX_A_star[s] <- rocX_B_star[s] <- rocResults[2]#
      #rocX_star[s] <- rocResults[2]#
      #Fit baseline risk model to entire cohort and get logit(P(D=1|X)) for each subject in case-ctrl subset#
      mod <- glm(dis~X,family=binomial(link="logit"),data=cohort)#
      cohort$rxCohort <- mod$fitted.values#
      cohort$origCCsubset <- 0#
      #Select nested cases#
      casesRisk  <- subset(cohort, dis==1)#
      randCases <- sample(seq(1:(dim(casesRisk)[1])), size=nd, replace = FALSE)#
      casesRisk$Y[-randCases] <- NA#
      #casesRisk$origCCsubset <- 0#
      casesRisk$origCCsubset[randCases] <- 1#
      casesRiskSub <- casesRisk[randCases,]#
      #modYX_cases <- lm(Y ~ X, data=ccCases)#
      modYX_cases <- lm(Y ~ X, data=casesRiskSub)#
      sigma_cases <- sd(modYX_cases$residuals)#
      modYX_resid_cases <- modYX_cases$residuals/sigma_cases#
      prevCohort <- nrow(casesRisk)/nrow(cohort)#
      #Select nested controls#
      ctrlsRisk <- subset(cohort, dis==0)#
      for(cc in 1:length(ccSubs)) {#
      	 ctrlsRisk$origCCsubset <- 0#
         if(ccSubs[cc]=="simple") {#
            #Simple Case-Control Design#
            randCtrls <- sample(seq(1:(dim(ctrlsRisk)[1])), size=r*nd, replace = FALSE)#
            #ctrlsRisk$origCCsubset[randCtrls] <- 1#
            ctrlsRiskSub <- ctrlsRisk[randCtrls,]#
            ccSubset <- as.data.frame( rbind(ctrlsRiskSub, casesRiskSub) )#
            origCtrls <- randCtrls#
         }#
         if(ccSubs[cc]=="freqMatch" | ccSubs[cc]=="hybrid") {#
            #Matched Case-Control Design#
            #Do matching to select controls#
            ctrlsRisk_overlap <- ctrlsRisk[ctrlsRisk$X >= min(casesRiskSub$X),]#
            binCuts <- cut2(ctrlsRisk_overlap$X, g=numBins, onlycuts=T)[2:(numBins)]#
            XctrlBins <- as.numeric(cut2(ctrlsRisk$X, cuts=binCuts ))#
            XcaseBins <- as.numeric( cut2(casesRiskSub$X, cuts=binCuts ))#
            if(is.na(mean(XctrlBins))) {#
               naIndices <- which(is.na(XctrlBins))#
               XctrlBins[naIndices] <- as.numeric( cut2(ctrlsRisk$X[naIndices], cuts=binCuts))#
            }#
            if(is.na(mean(XcaseBins))) {#
               naIndices <- which(is.na(XcaseBins))#
               XcaseBins[naIndices] <- as.numeric( cut2(casesRiskSub$X[naIndices], cuts=binCuts))#
            }#
            #Put overlapping controls in bins#
            #XctrlBins <- as.numeric(cut2(Xctrl_overlapToUseForMakingBins, g=numBins[b]))#
            #XctrlBins <- as.numeric(cut2(ctrlsRisk$X, g=numBins[b]))#
            #Controls that are smallest than the smallest case go in bin 1, so add those in#
            nbins_cases <- unlist( lapply(seq(1:numBins), FUN=function(x){sum(XcaseBins==x)} ) )#
            if(ccSubs[cc]=="freqMatch") {#
               #Frequency-Matched Design#
               matchedCtrls <- lapply( seq(1:numBins), FUN=function(x) #
                  { sample(which(XctrlBins==x),r*(nbins_cases[x])) } )#
               #ctrlsRisk$origCCsubset[unlist(matchedCtrls)] <- 1#
               XctrlSubBins <- XctrlBins[unlist(matchedCtrls)]#
               ctrlsRiskSub <- ctrlsRisk[unlist(matchedCtrls),]#
               ccSubset <- as.data.frame( rbind(ctrlsRiskSub,casesRiskSub) )#
               origCtrls <- unlist(matchedCtrls)#
            }#
            if(ccSubs[cc]=="hybrid") {#
               #Hybrid Matched-Unmatched Design#
               nbins_check <- r1*(nbins_cases)#
               if(sum(floor(nbins_check)) < r1*nd) {#
               	  indices <- which(floor(nbins_check) != nbins_check)#
               	  pickIndicesToRoundUp <- sample(length(indices), 0.5*length(indices), replace=F)#
               	  indicesToRoundUp <- indices[pickIndicesToRoundUp]#
               	  nbins_check[indicesToRoundUp] <- ceiling(nbins_check[indicesToRoundUp])#
               	  nbins_check[indices[-indicesToRoundUp]] <- floor(nbins_check[indices[-indicesToRoundUp]])#
               }#
               matchedCtrls <- lapply( seq(1:numBins), FUN=function(x)#
                  { sample(which(XctrlBins==x), nbins_check[x] ) } )#
#               matchedCtrls <- lapply( seq(1:numBins), FUN=function(x)#
#                  { sample(which(XctrlBins==x),r1*(nbins_cases[x])) } )#
               remainingCtrls <- XctrlBins#
               remainingCtrls[unlist(matchedCtrls)] <- 0#
               SRS <- sample(which(remainingCtrls!=0),(r-r1)*nd,replace=F)#
               #ctrlsRisk$origCCsubset[c(unlist(matchedCtrls),SRS)] <- 1#
               XctrlSubBins <- c(XctrlBins[unlist(matchedCtrls)], XctrlBins[SRS])#
               ctrlsRiskSub <- ctrlsRisk[c(unlist(matchedCtrls),unlist(SRS)),]#
               ccSubset <- as.data.frame( rbind(ctrlsRiskSub,casesRiskSub) )#
               origCtrls <- c(unlist(matchedCtrls),SRS)#
            }#
         }#
         ctrlsRisk$origCCsubset[origCtrls] <- 1#
         #ctrlsRisk$Y[-origCtrls] <- NA#
         SxyResults <- getSxy(ccSubset, mod, nd, r, casesRisk, ctrlsRisk)#
         mod_cc <- SxyResults[[2]]#
         Sxy <- SxyResults[[1]]#
         ccSubset$SxyA <- Sxy[,1]#
         ccSubset$SxyB <- Sxy[,2]#
         ccCtrls <- subset(ccSubset, dis==0)#
         ccCases <- subset(ccSubset, dis==1)#
##Check distribution of control residuals within each stratum#
# plot(density(modYX_resid[XctrlSubBins==1]), ylim=c(0,0.5))#
# lines(density(modYX_resid[XctrlSubBins==2]))#
# lines(density(modYX_resid[XctrlSubBins==3]), col="red")#
# lines(density(modYX_resid[XctrlSubBins==4]), col="blue")#
##Check distribution of case residuals within each stratum#
# plot(density(modYX_resid_cases[XcaseBins==1]), ylim=c(0,0.5))#
# lines(density(modYX_resid_cases[XcaseBins==2]))#
# lines(density(modYX_resid_cases[XcaseBins==3]), col="red")#
# lines(density(modYX_resid_cases[XcaseBins==4]), col="blue")#
         if(semiparam) {#
            modYX <- lm(Y ~ X, data=ccCtrls)#
            sigma <- sd(modYX$residuals)#
            modYX_resid <- modYX$residuals/sigma#
    	      modYX_fitted <- modYX$coeff[1] + modYX$coeff[2]*(ctrlsRisk$X)#
            F0 <- ecdf(modYX_resid)#
            ##modYX <- lm(Y ~ ns(X, df=2), data=ccCtrls)#
            #modYX <- lm(Y ~ ns(X), data=ccCtrls)#
            #sigma2Hat <- (modYX$residuals)^2#
            ##modYX_sigma <- glm(sigma2Hat ~ ns(X, df=2), family=gaussian(link="log"), data=ccCtrls)#
            #modYX_sigma <- glm(sigma2Hat ~ ns(X), family=gaussian(link="log"), data=ccCtrls)#
            #muX <- modYX$fitted.values#
            #sigmaX2 <- predict(modYX_sigma, type="response")#
            ##sigmaX2[which(sigmaX2 < 0)] <- NA#
            #sigmaX <- sqrt(sigmaX2)#
            #modYX_resid <- (ccCtrls$Y - muX)/sigmaX#
            #F0 <- ecdf(modYX_resid)#
            ##muX_cohort <- modYX$coeff[1] + modYX$coeff[2:3]*ns(ctrlsRisk$X, df=2)#
            ##sigmaX_cohort <- exp(modYX_sigma$coeff[1] + modYX_sigma$coeff[2:3]*ns(ctrlsRisk$X, df=2))#
            #muX_cohort <- modYX$coeff[1] + modYX$coeff[2]*ns(ctrlsRisk$X)#
            #sigmaX_cohort <- exp(modYX_sigma$coeff[1] + modYX_sigma$coeff[2]*ns(ctrlsRisk$X))#
            #muX_cohort <- modYX$coeff[1] + modYX$coeff[2]*(ctrlsRisk$X)#
            #sigmaX_cohort <- exp(modYX_sigma$coeff[1] + modYX_sigma$coeff[2]*(ctrlsRisk$X))#
            for(sxy in 1:ncol(Sxy)) {#
               if(methA & sxy==1)#
                  cThreshY <- mod$coeff[1] + (ctrlsRisk$X)*mod$coeff[2] - mod_cc$coeff[1] - #
                     mod_cc$coeff[2]*(ctrlsRisk$X) + mod_cc$coeff[3] + mod_cc$coeff[4]*(ctrlsRisk$X)#
               else#
                  cThreshY <- mod_cc$coeff[3] + mod_cc$coeff[4]*(ctrlsRisk$X) + log(nrow(casesRisk)/nrow(ctrlsRisk)) - log(nd/(r*nd))#
               if(roc) {#
                  cThresh <- seq(max(Sxy[1:(r*nd),sxy])+.001,min(Sxy[1:(r*nd),sxy])-.001,by=-0.001)#
                  #semi-parametric, using HP#
                  for(k in 1:length(cThresh)) {#
                     cThreshY_curr <- ( log(cThresh[k]/(1-cThresh[k])) - cThreshY)/mod_cc$coeff[5]#
                     quant <- mean( F0((cThreshY_curr - modYX_fitted)/sigma) )#
                     #quant <- mean( F0((cThreshY_curr - muX_cohort)/sigmaX_cohort) )#
                     if(quant >= 1-t) currQuant <- quant#
                     if(k<length(cThresh) & quant < (1-t)) {#
                        quantUsed_semi_HP_star[s,cc] <- currQuant#
                        break#
                     }#
                  }#
                  cFPF0.05 <- ifelse(k==1, NA, cThresh[k-1])#
                  quantJustAfter_semi_HP_star[s,cc] <- quant#
                  if(methA & sxy==1)#
                     rocXY_A_star[s,cc+3] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy[((r*nd+1):(nrow(Sxy))),sxy] <= cFPF0.05))#
                  else#
                     rocXY_B_star[s,cc+3] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy[(r*nd+1):(nrow(Sxy)),sxy] <= cFPF0.05))#
               }#
               if(auc) {#
                  #Sxy_auc_param <- vector(length=nd)#
                  Sxy_auc_HP <- vector(length=nd)#
                  for(nd_i in 1:nd) {#
                     cThreshY_curr <- ( log(Sxy[(nd_i + r*nd),sxy]/(1-Sxy[(nd_i + r*nd),sxy])) - cThreshY)/mod_cc$coeff[5]#
                     #Sxy_auc_param[nd_i] <- mean( pnorm(cThreshY_curr, mean=rho*ctrlsRisk$X, sd=sqrt(1-rho^2)) )#
                     Sxy_auc_HP[nd_i] <- mean( F0(cThreshY_curr - modYX_fitted) )#
                  }#
                  if(methA & sxy==1) {#
                     aucXY_A_star[s,cc+3] <- mean(Sxy_auc_HP)#
                     #aucXY_A_star[s,cc+6] <- mean(Sxy_auc_param)#
                  }#
                  else {#
                     aucXY_B_star[s,cc+3] <- mean(Sxy_auc_HP)#
                     #aucXY_B_star[s,cc+6] <- mean(Sxy_auc_param)#
                  }#
               }#
               if(nri) {#
                  cThreshY_curr <- ( log(ctrlsRisk$rxCohort/(1-ctrlsRisk$rxCohort)) - cThreshY)/mod_cc$coeff[5]#
                  #calcNRI_nonparam(Sxy[((nd*r+1):(nd*r+nd)), sxy], ccCases$rxCohort, NULL, NULL , match=F)#
                  #calcNRI_semi( , match=F)#
                  #calcNRI_param( , match=F)#
                  currEvent <- 2*mean( Sxy[((nd*r+1):(nd*r+nd)), sxy] > ccCases$rxCohort ) - 1#
                  #currNonevent_param <- 2*(mean( pnorm(cThreshY_curr, mean=rho*ctrlsRisk$X, sd=sqrt(1-rho^2)) )) - 1#
                  currNonevent_HP <- 2*(mean( F0(cThreshY_curr - modYX_fitted) )) - 1#
                  if(methA & sxy==1){#
                     #nriEvent_A_star[s,cc+3] <- nriEvent_A_star[s,cc+6] <- currEvent#
                     #nriNonevent_A_star[s,cc+6] <- currNonevent_param#
                     nriEvent_A_star[s,cc+3] <- currEvent#
                     nriNonevent_A_star[s,cc+3] <- currNonevent_HP#
                  }#
                  else {#
                     #nriEvent_B_star[s,cc+3] <- nriEvent_B_star[s,cc+6] <- currEvent#
                     #nriNonevent_B_star[s,cc+6] <- currNonevent_param#
                     nriEvent_B_star[s,cc+3] <- currEvent#
                     nriNonevent_B_star[s,cc+3] <- currNonevent_HP#
                  }#
               }#
               if(idi) {#
                  #cThresh <- seq(0,1,by=0.005)#
                  cThresh <- seq(0,1,by=0.0001)#
                  ##quant_yxCond#
                  #quants <- vector(length=length(cThresh))#
                  #for(k in 1:length(cThresh)) {#
                  #   cThreshY_curr <- ( log(cThresh[k]/(1-cThresh[k])) - cThreshY)/mod_cc$coeff[5]#
                  #   quants[k] <- 1 - mean( pnorm(cThreshY_curr, mean=rho*ctrlsRisk$X, sd=sqrt(1-rho^2)) )#
                  #}#
                  #currNonevent_yxCond <- mean(ctrlsRisk$rxCohort) - mean(quants)#
                  #quant_HP#
                  quants <- vector(length=length(cThresh))#
                  for(k in 1:length(cThresh)) {#
                     cThreshY_curr <- ( log(cThresh[k]/(1-cThresh[k])) - cThreshY)/mod_cc$coeff[5]#
                     quants[k] <- 1 - mean( F0(cThreshY_curr - modYX_fitted) )#
                  }#
                  currNonevent_HP <- mean(ctrlsRisk$rxCohort) - mean(quants)#
                  currEvent <- mean(Sxy[((nd*r+1):(nd*r+nd)), sxy]) - mean(casesRisk$rxCohort)#
                  if(methA & sxy==1){#
                     #idiEvent_A_star[s,cc+3] <- idiEvent_A_star[s,cc+6] <- currEvent#
                     #idiNonevent_A_star[s,cc+6] <- currNonevent_yxCond#
                     idiEvent_A_star[s,cc+3] <- currEvent#
                     idiNonevent_A_star[s,cc+3] <- currNonevent_HP#
                  }#
                  else {#
                     #idiEvent_B_star[s,cc+3] <- idiEvent_B_star[s,cc+6] <- currEvent#
                     #idiNonevent_B_star[s,cc+6] <- currNonevent_yxCond#
                     idiEvent_B_star[s,cc+3] <- currEvent#
                     idiNonevent_B_star[s,cc+3] <- currNonevent_HP#
                  } #
               }#
               if(tg) {#
                  cThreshY_curr <- ( log(prevCohort/(1-prevCohort)) - cThreshY)/mod_cc$coeff[5]#
                  currEvent <- mean(Sxy[((nd*r+1):(nd*r+nd)), sxy] > prevCohort) - mean(casesRisk$rxCohort > prevCohort)#
                  #currNonevent_yxCond <- mean(ctrlsRisk$rxCohort > prevCohort) - 1 + mean( pnorm(cThreshY_curr, mean=rho*ctrlsRisk$X, sd=sqrt(1-rho^2)) )#
                  currNonevent_HP <- mean(ctrlsRisk$rxCohort > prevCohort) - 1 + mean( F0(cThreshY_curr - modYX_fitted) )#
                  if(methA & sxy==1){#
                     #tgEvent_A_star[s,cc+3] <- tgEvent_A_star[s,cc+6] <- currEvent#
                     #tgNonevent_A_star[s,cc+6] <- currNonevent_yxCond#
                     tgEvent_A_star[s,cc+3] <- currEvent#
                     tgNonevent_A_star[s,cc+3] <- currNonevent_HP#
                  }#
                  else {#
                     #tgEvent_B_star[s,cc+3] <- tgEvent_B_star[s,cc+6] <- currEvent#
                     #tgNonevent_B_star[s,cc+6] <- currNonevent_yxCond#
                     tgEvent_B_star[s,cc+3] <- currEvent#
                     tgNonevent_B_star[s,cc+3] <- currNonevent_HP#
                  }                  #
               }#
            } #sxy for loop#
         } #if semiparam#
         if(nonparam) {#
            if(ccSubs[cc]=="simple") {#
               if(roc | auc) {#
                  ccD <<- ccSubset$dis#
                  SxyA <<- ccSubset$SxyA#
                  #SxyA <<- Sxy[,1]#
                  rocResults <- comproc(d="ccD", markers="SxyA", roc=t, auc=T, nobstrap=T)#
                  aucXY_A_star[s,cc] <- rocResults[1]#
                  rocXY_A_star[s,cc] <- rocResults[2]#
                  SxyB <<- ccSubset$SxyB#
                  #SxyB <<- Sxy[,2]#
                  rocResults <- comproc(d="ccD", markers="SxyB", roc=t, auc=T, nobstrap=T)#
                  aucXY_B_star[s,cc] <- rocResults[1]#
                  rocXY_B_star[s,cc] <- rocResults[2]#
               }#
               if(nri) {#
                  nriEvent_A_star[s,cc] <- 2*mean( ccCases$SxyA > ccCases$rxCohort ) - 1#
                  nriNonevent_A_star[s,cc] <- 1 - 2*mean( ccCtrls$SxyA > ccCtrls$rxCohort )#
                  nriEvent_B_star[s,cc] <- 2*mean( ccCases$SxyB > ccCases$rxCohort )  - 1#
                  nriNonevent_B_star[s,cc] <- 1 - 2*mean( ccCtrls$SxyB > ccCtrls$rxCohort )#
               }#
               if(idi) {#
                  idiEvent_A_star[s,cc] <- mean(ccCases$SxyA) - mean(casesRisk$rxCohort)#
                  idiNonevent_A_star[s,cc] <- mean(ctrlsRisk$rxCohort) - mean(ccCtrls$SxyA )#
                  idiEvent_B_star[s,cc] <- mean(ccCases$SxyB) - mean(casesRisk$rxCohort)#
                  idiNonevent_B_star[s,cc] <- mean(ctrlsRisk$rxCohort) - mean(ccCtrls$SxyB )#
               }#
               if(tg) {#
                  tgEvent_A_star[s,cc] <- mean(ccCases$SxyA > prevCohort) - mean(casesRisk$rxCohort > prevCohort)#
                  tgNonevent_A_star[s,cc] <- mean(ctrlsRisk$rxCohort > prevCohort) - mean(ccCtrls$SxyA > prevCohort)#
                  tgEvent_B_star[s,cc] <- mean(ccCases$SxyB > prevCohort) - mean(casesRisk$rxCohort > prevCohort)#
                  tgNonevent_B_star[s,cc] <- mean(ctrlsRisk$rxCohort > prevCohort) - mean(ccCtrls$SxyB > prevCohort)#
               }#
            }#
            if(ccSubs[cc]=="freqMatch" | ccSubs[cc]=="hybrid") {#
               #Calculate fpfsXY#
               Nbins <- unlist( lapply(sort(unique(XctrlBins)), FUN=function(x){sum(XctrlBins==x)} ) )#
               binWeights <- Nbins/nrow(ctrlsRisk)#
               nbins <- unlist( lapply(sort(unique(XctrlBins)), FUN=function(x){sum(XctrlSubBins==x)} ) )#
               if(min(nbins) == 0) {#
                  print("Empty bins")#
                  countEmptyBins[,cc] <- countEmptyBins[,cc] + 1#
               }#
               else{ #
                  for(sxy in 1:ncol(Sxy)) {#
                     #Estimate case and ctrl popn distns of S(X,Y) using book, ch.2#
                     if(roc) { #
                        cThresh <- seq(max(Sxy[1:(r*nd),sxy])+.001,min(Sxy[1:(r*nd),sxy])-.001,by=-0.001)#
                        #cThresh <- seq(max(Sxy[,sxy])+.001,min(Sxy[,sxy])-.001,by=-0.001)#
                        #cThresh <- seq(max(ccCtrls$SxyA)+.001,min(ccCtrls$SxyA)-.001,by=-0.001)#
                        binSums <- rep(0,numBins)#
                        for(k in 1:length(cThresh)) {#
                           binSums <- unlist( lapply( seq(1:numBins), #
                              function(x){ sum(Sxy[which(XctrlSubBins==x),sxy] <= cThresh[k]) } ) )#
                           quant <- sum(binWeights * binSums/nbins)#
                           if(quant >= 1-t) currQuant <- quant#
                           if(k<length(cThresh) & quant < (1-t)) {#
                              quantUsed_star[s,cc] <- currQuant#
                              break#
                           }#
                        }#
                        cFPF0.05 <- ifelse(k==1, NA, cThresh[k-1])#
                        quantJustAfter_star[s,cc] <- quant#
                        if(methA & sxy==1)#
                           rocXY_A_star[s,cc] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy[((r*nd+1):(nrow(Sxy))),sxy] <= cFPF0.05))#
                        else#
                           rocXY_B_star[s,cc] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy[(r*nd+1):(nrow(Sxy)),sxy] <= cFPF0.05))#
                     }#
                     if(auc) {#
                        Sxy_auc <- vector(length=nd)#
                        for(nd_i in 1:nd) {#
                           binSums <- unlist( lapply( seq(1:numBins), function(x){ sum(Sxy[which(XctrlSubBins==x),sxy] > Sxy[nd_i + r*nd, sxy] ) } ) )#
                           Sxy_auc[nd_i] <- sum(binWeights * binSums/nbins)#
                        }#
                        currAuc <- 1 - mean(Sxy_auc)#
                        if(methA & sxy==1) aucXY_A_star[s,cc] <- currAuc#
                        else aucXY_B_star[s,cc] <- currAuc#
                     }#
                     if(nri) {#
                        currEvent <- 2*mean( Sxy[((nd*r+1):(nd*r+nd)), sxy] > ccCases$rxCohort ) - 1#
                        binMeans <- unlist( lapply( seq(1:numBins), function(x){mean( Sxy[which(XctrlSubBins==x), sxy] > ccCtrls$rxCohort[which(XctrlSubBins==x)] )} ) )#
                        currNonevent <- 1 - 2*sum(binWeights * binMeans)#
                        if(methA & sxy==1){#
                           nriEvent_A_star[s,cc] <- currEvent#
                           nriNonevent_A_star[s,cc] <- currNonevent#
                        }#
                        else {#
                           nriEvent_B_star[s,cc] <- currEvent#
                           nriNonevent_B_star[s,cc] <- currNonevent#
                        }#
                     }#
                     if(idi) {#
                        currEvent <- mean(Sxy[((nd*r+1):(nd*r+nd)), sxy]) - mean(casesRisk$rxCohort)#
                        binMeans <- unlist( lapply( seq(1:numBins), function(x){mean( Sxy[which(XctrlSubBins==x), sxy] )} ) )#
                        currNonevent <- mean(ctrlsRisk$rxCohort) - sum(binWeights * binMeans)#
                        if(methA & sxy==1){#
                           idiEvent_A_star[s,cc] <- currEvent#
                           idiNonevent_A_star[s,cc] <- currNonevent#
                        }#
                        else {#
                           idiEvent_B_star[s,cc] <- currEvent#
                           idiNonevent_B_star[s,cc] <- currNonevent#
                        }#
                     }#
                     if(tg) {#
                        currEvent <- mean(Sxy[((nd*r+1):(nd*r+nd)), sxy] > prevCohort) - mean(casesRisk$rxCohort > prevCohort)#
                        binMeans <- unlist( lapply( seq(1:numBins), function(x){mean( Sxy[which(XctrlSubBins==x), sxy] > prevCohort )} ) )#
                        currNonevent <- mean(ctrlsRisk$rxCohort > prevCohort) - sum(binWeights * binMeans)#
                        if(methA & sxy==1){#
                           tgEvent_A_star[s,cc] <- currEvent#
                           tgNonevent_A_star[s,cc] <- currNonevent#
                        }#
                        else {#
                           tgEvent_B_star[s,cc] <- currEvent#
                           tgNonevent_B_star[s,cc] <- currNonevent#
                        }#
                     }#
                     # #Figure out this issue in comproc#
                     # #   rocX <- comproc(d="cohort$dis", markers="cohort$X", roc=0.05, nobstrap=T)#
                     # #   rocXY <- comproc(d="ccSubset$dis", markers="Sxy", roc=0.05, nobstrap=T)#
                  } #sxy for loop#
               } #else#
            } #if matched#
         } #if nonparam#
         ###########
         #Bootstrap#
         ###########
         cohort_imputed <- rbind(ctrlsRisk,casesRisk)#
         for(b in 1:nBoot) {#
            print(paste(s,b))#
            resample.cohort <- sample(1:nrow(cohort_imputed), size=nrow(cohort_imputed), replace=TRUE)#
            cohort.star <- as.data.frame(cohort_imputed[resample.cohort,])#
            #Fit baseline risk model to entire cohort and get logit(P(D=1|X)) for each subject in case-ctrl subset#
            mod.star <- try(glm(dis~X,family=binomial(link="logit"),data=cohort.star),FALSE)#
            failed <- inherits(mod.star,"try-error")#
            if(failed || !mod.star$converged)#
               next#
            cohort.star$rxCohort <- mod.star$fitted.values#
            #ROC_x, AUC_x#
            cohortD.star <<- cohort.star$dis#
            #rxCohort.star <<- cohort.star$rxCohort#
            cohortX.star <<- cohort.star$X#
            rocResults <- comproc(d="cohortD.star", markers=c("cohortX.star"), roc=t, auc=T, nobstrap=T)#
            rocX.star1[b,] <- rocResults[2]#
            aucX.star1[b,] <- rocResults[1]#
            #Select nested cases#
            casesRisk.star  <- subset(cohort.star, dis==1)#
            randCases.star <- sample(seq(1:nrow(casesRisk.star)), size=nd, replace = FALSE)#
            casesRiskSub.star <- casesRisk.star[randCases.star,]#
            prevCohort.star <- nrow(casesRisk.star)/nrow(cohort.star)#
            #casesRiskSub.star <- casesRisk.star#
            #nd.star <- nrow(casesRiskSub.star)#
            #Selected nested controls#
            ctrlsRisk.star <- subset(cohort.star, dis==0)#
            if(ccSubs[cc]=="simple") {#
               #Simple Case-Control Design#
               randCtrls.star <- sample(seq(1:nrow(ctrlsRisk.star)), size=r*nd, replace = F)#
               ctrlsRiskSub.star <- ctrlsRisk.star[randCtrls.star,]#
               #ccSubset.star <- as.data.frame( rbind(ctrlsRiskSub.star, casesRiskSub.star) )#
            }#
            if(ccSubs[cc]=="freqMatch" | ccSubs[cc]=="hybrid") {#
               #Matched Case-Control Design#
               #Do matching to select controls#
               ctrlsRisk_overlap.star <- ctrlsRisk.star[ctrlsRisk.star$X >= min(casesRiskSub.star$X),]#
               binCuts.star <- cut2(ctrlsRisk_overlap.star$X, g=numBins, onlycuts=T)[2:(numBins)]#
               XctrlBins.star <- as.numeric(cut2(ctrlsRisk.star$X, cuts=binCuts.star ))#
               XcaseBins.star <- as.numeric( cut2(casesRiskSub.star$X, cuts=binCuts.star ))#
               if(is.na(mean(XctrlBins.star))) {#
                  naIndices <- which(is.na(XctrlBins.star))#
                  XctrlBins.star[naIndices] <- as.numeric( cut2(ctrlsRisk.star$X[naIndices], cuts=binCuts.star))#
               }#
               if(is.na(mean(XcaseBins.star))) {#
                  naIndices <- which(is.na(XcaseBins.star))#
                  XcaseBins.star[naIndices] <- as.numeric( cut2(casesRiskSub.star$X[naIndices], cuts=binCuts.star))#
               }#
               #Controls that are smaller than the smallest case go in bin 1, so add those in#
               nbins_cases.star <- unlist( lapply(seq(1:numBins), FUN=function(x){sum(XcaseBins.star==x)} ) )#
               #nbins_ctrls <- unlist( lapply(seq(1:numBins), FUN=function(x){sum(XctrlBins==x)} ) )#
               #nbins_ctrls_sub <- unlist( lapply(seq(1:numBins), FUN=function(x){sum(XctrlSubBins==x)} ) )#
               if(ccSubs[cc]=="freqMatch") {#
                  #Frequency-Matched Design#
                  matchedCtrls.star <- lapply( seq(1:numBins), FUN=function(x){ sample(which(XctrlBins.star==x),r*(nbins_cases.star[x]), replace=F) } )#
                  XctrlSubBins.star <- XctrlBins.star[unlist(matchedCtrls.star)]#
                  ctrlsRiskSub.star <- ctrlsRisk.star[unlist(matchedCtrls.star),]#
                  #ccSubset.star <- as.data.frame( rbind(ctrlsRiskSub.star,casesRiskSub.star) )#
               }#
               if(ccSubs[cc]=="hybrid") {#
                  #Hybrid Matched-Unmatched Design#
                  nbins_check.star <- r1*(nbins_cases.star)#
                  if(sum(floor(nbins_check.star)) < r1*nd) {#
               	     indices <- which(floor(nbins_check.star) != nbins_check.star)#
                	 pickIndicesToRoundUp <- sample(length(indices), 0.5*length(indices), replace=F)#
               	     indicesToRoundUp <- indices[pickIndicesToRoundUp]#
               	     nbins_check.star[indicesToRoundUp] <- ceiling(nbins_check.star[indicesToRoundUp])#
               	     nbins_check.star[indices[-indicesToRoundUp]] <- floor(nbins_check.star[indices[-indicesToRoundUp]])#
                  }                #
                   matchedCtrls.star <- lapply( seq(1:numBins), FUN=function(x)#
                     { sample(which(XctrlBins.star==x), nbins_check.star[x], replace=F) } )#
#                  matchedCtrls.star <- lapply( seq(1:numBins), FUN=function(x)#
#                     { sample(which(XctrlBins.star==x),r1*(nbins_cases.star[x]), replace=F) } )#
                  remainingCtrls.star <- XctrlBins.star#
                  remainingCtrls.star[unlist(matchedCtrls.star)] <- 0#
                  SRS.star <- sample(which(remainingCtrls.star!=0),(r-r1)*nd, replace=F)#
                  XctrlSubBins.star <- c(XctrlBins.star[unlist(matchedCtrls.star)], XctrlBins.star[SRS.star])#
                  ctrlsRiskSub.star <- ctrlsRisk.star[c(unlist(matchedCtrls.star),unlist(SRS.star)),]#
                  #ccSubset.star <- as.data.frame( rbind(ctrlsRiskSub.star,casesRiskSub.star) )#
               }#
            } #if(freqMatch or hybrid)#
            ##For parametric bootstrap, generate Y values for controls selected in nested case-control subset#
            #ccSubset.star$Ycohort <- ccSubset.star$Y#
            #ctrlsY.star <- modYX$coeff[1] + (modYX$coeff[2])*(ctrlsRiskSub.star$X) + sigma*(sample(modYX_resid, nrow(ctrlsRiskSub.star), replace=T))#
            #casesY.star <- modYX_cases$coeff[1] + (modYX_cases$coeff[2])*(casesRiskSub.star$X) + sigma_cases*(sample(modYX_resid_cases, nrow(casesRiskSub.star), replace=T))#
            #ccSubset.star$Y <-  c(ctrlsY.star, casesY.star)#
            ##ccSubset.star$Y <- modYX$coeff[1] + (modYX$coeff[2])*(ccSubset.star$X)#
            ##ccSubset.star$Y_param <- rnorm(n=nrow(ccSubset.star), mean=rho*(ccSubset.star$X), sd=sqrt(1-rho^2))#
            ##ccSubset.star$Y <- modYX$coeff[1] + (modYX$coeff[2])*ns(ccSubset.star$X) + #
            ##   (exp(modYX_sigma$coeff[1] + modYX_sigma$coeff[2]*ns(ccSubset.star$X)))*(sample(modYX_resid, nrow(ccSubset.star), replace=T))#
            #Impute Y values for bootstrapped cases who weren't in original phase 1 CC-subset#
            casesToImpute <- which(casesRiskSub.star$origCCsubset==0)#
            casesY.imputed <- casesRiskSub.star$Y#
            casesY.imputed[casesToImpute] <- modYX_cases$coeff[1] + (modYX_cases$coeff[2])*(casesRiskSub.star$X[casesToImpute]) + sigma_cases*(sample(modYX_resid_cases, length(casesToImpute), replace=T))#
            casesRiskSub.star$Y <- casesY.imputed      #
            #Impute Y values for bootstrapped controls who weren't in original phase 1 CC-subset#
            #Sampling from all residuals#
            #ctrlsY.imputed <- ctrlsRisk_imputed$Y#
            #ctrlsY.imputed[-origCtrls] <- modYX$coeff[1] + (modYX$coeff[2])*(ctrlsRisk$X[-origCtrls]) + sigma*(sample(modYX_resid, nrow(ctrlsRisk_imputed)-nd*r, replace=T))#
            #ctrlsRisk_imputed$Y <- ctrlsY.imputed#
            ctrlsToImpute <- which(ctrlsRiskSub.star$origCCsubset==0)#
            ctrlsY.imputed <- ctrlsRiskSub.star$Y#
            ctrlsY.imputed[ctrlsToImpute] <- NA#
            #Sampling from all residuals#
            if(ccSubs[cc]=="simple") {#
               ctrlsY.imputed[ctrlsToImpute] <- modYX$coeff[1] + (modYX$coeff[2])*(ctrlsRiskSub.star$X[ctrlsToImpute]) + sigma*(sample(modYX_resid, length(ctrlsToImpute), replace=T))#
            }   #
            #Sampling residuals within strata#
            if(ccSubs[cc]=="freqMatch" | ccSubs[cc]=="hybrid") {#
               for(i in 1:numBins) {#
                  currY <- ctrlsY.imputed[XctrlSubBins.star==i]#
                  currX <- ctrlsRiskSub.star$X[XctrlSubBins.star==i]#
                  currY[which(is.na(currY))] <- modYX$coeff[1] + (modYX$coeff[2])*(currX[which(is.na(currY))]) + #
                     sigma*(sample(modYX_resid[XctrlSubBins.star==i], sum(is.na(currY)), replace=T))#
                  ctrlsY.imputed[which(XctrlSubBins.star==i)] <- currY#
               }#
            }#
            ctrlsRiskSub.star$Y <- ctrlsY.imputed#
            ccSubset.star <- as.data.frame( rbind(ctrlsRiskSub.star,casesRiskSub.star) )#
            SxyResults.star <- getSxy(ccSubset.star, mod.star, nd, r, casesRisk.star, ctrlsRisk.star)#
            mod_cc.star <- SxyResults.star[[2]]#
            Sxy.star <- SxyResults.star[[1]]#
            ccSubset.star$SxyA <- Sxy.star[,1]#
            ccSubset.star$SxyB <- Sxy.star[,2]#
            ccCtrls.star <- subset(ccSubset.star, dis==0)#
            ccCases.star <- subset(ccSubset.star, dis==1)#
            if(semiparam) {#
               modYX.star <- lm(Y ~ X, data=ccCtrls.star)#
               #modYX.star <- lm(Ycohort ~ X, data=ccCtrls.star)#
               modYX_fitted.star <- modYX.star$coeff[1] + modYX.star$coeff[2]*(ctrlsRisk.star$X)#
               #rX_ctrlsRisk.star <- cbind(rep(1,nrow(ctrlsRisk.star)), ctrlsRisk.star$rxCohort)#
               #sigma.star <- sd(ccCtrls.star$logscr)#
               sigma.star <- sd(modYX.star$residuals)#
               modYX_resid.star <- (modYX.star$residuals)/sigma.star#
               F0.star <- ecdf(modYX_resid.star)#
               for(sxy in 1:ncol(Sxy.star)) {#
                  if(methA & sxy==1)#
                     cThreshY <- mod.star$coeff[1] + (ctrlsRisk.star$X)*(mod.star$coeff[2]) - mod_cc.star$coeff[1] - #
                        (mod_cc.star$coeff[2])*(ctrlsRisk.star$X) + mod_cc.star$coeff[3] + (mod_cc.star$coeff[4])*(ctrlsRisk.star$X)#
                  else#
                     cThreshY <- mod_cc.star$coeff[3] + mod_cc.star$coeff[4]*(ctrlsRisk.star$X) + log(nrow(casesRisk.star)/nrow(ctrlsRisk.star)) - log(nd/(r*nd))#
                  if(roc) {#
                     cThresh <- seq(max(Sxy.star[1:(nrow(ctrlsRiskSub.star)),sxy])+.001,min(Sxy.star[1:(nrow(ctrlsRiskSub.star)),sxy])-.001,by=-0.001)#
                     #cThresh <- seq(1-.001,min(Sxy[1:(r*nd),sxy])-.001,by=-0.001)#
                     #cThresh <- seq(0.75,min(Sxy[1:(r*nd),sxy])-.001,by=-0.001)#
                     ##parametric#
                     #for(k in 1:length(cThresh)) {#
                     #   cThreshY_curr <- ( log(cThresh[k]/(1-cThresh[k])) - cThreshY)/mod_cc.star$coeff[5]#
                     #   quant <- mean( pnorm(cThreshY_curr, mean=rho*ctrlsRisk.star$X, sd=sqrt(1-rho^2)) )#
                     #   currQuant <- quant#
                     #   #if(quant >= 1-t) currQuant <- quant#
                     #   if(k<length(cThresh) & quant < (1-t)) {#
                     #      if(methA & sxy==1)#
                     #         quantUsed.star1.A[b,(cc+6)] <- currQuant#
                     #      else#
                     #         quantUsed.star1.B[b,(cc+6)] <- currQuant#
                     #      break#
                     #   }#
                     #}#
                     #cFPF0.05 <- ifelse(k==1, NA, cThresh[k-1])#
                     #if(methA & sxy==1)#
                     #   quantJustAfter.star1.A[b,(cc+6)] <- quant#
                     #else#
                     #   quantJustAfter.star1.B[b,(cc+6)] <- quant#
                     ##
                     #if(methA & sxy==1)#
                     #   rocXY.star1.A[b,(cc+6)] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(Sxy.star))),sxy] <= cFPF0.05))#
                     #else#
                     #   rocXY.star1.B[b,(cc+6)] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(Sxy.star))),sxy] <= cFPF0.05))#
                     #semi-parametric, HP#
                     for(k in 1:length(cThresh)) {#
                        cThreshY_curr <- ( log(cThresh[k]/(1-cThresh[k])) - cThreshY)/mod_cc.star$coeff[5]#
                        quant <- mean( F0.star( (cThreshY_curr - modYX_fitted.star)/sigma.star) )#
                        if(quant >= 1-t) currQuant <- quant#
                        if(k<length(cThresh) & quant < (1-t)) {#
                           if(methA & sxy==1)#
                              quantUsed.star1.A[b,(cc+3)] <- currQuant#
                           else#
                              quantUsed.star1.B[b,(cc+3)] <- currQuant#
                           break#
                        }#
                     }#
                     cFPF0.05 <- ifelse(k==1, NA, cThresh[k-1])#
                     if(methA & sxy==1)#
                        quantJustAfter.star1.A[b,(cc+3)] <- quant#
                     else#
                        quantJustAfter.star1.B[b,(cc+3)] <- quant#
                     if(methA & sxy==1)#
                        rocXY.star1.A[b,(3+cc)] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(Sxy.star))),sxy] <= cFPF0.05))#
                     else#
                        rocXY.star1.B[b,(3+cc)] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(Sxy.star))),sxy] <= cFPF0.05))#
                  }#
                  if(auc) {#
                     #Sxy_auc_param <- vector(length=nd)#
                     Sxy_auc_HP <- vector(length=nd)#
                     for(nd_i in 1:nd) {#
                        cThreshY_curr <- ( log(Sxy.star[(nd_i + nrow(ctrlsRiskSub.star)),sxy]/(1-Sxy.star[(nd_i + nrow(ctrlsRiskSub.star)),sxy])) - cThreshY)/mod_cc.star$coeff[5]#
                        #Sxy_auc_param[nd_i] <- mean( pnorm(cThreshY_curr, mean=rho*ctrlsRisk.star$X, sd=sqrt(1-rho^2)) )#
                        Sxy_auc_HP[nd_i] <- mean( F0( (cThreshY_curr - modYX_fitted.star)/sigma.star ) )#
                     }#
                     if(methA & sxy==1) {#
                        aucXY.star1.A[b,(cc+3)] <- mean(Sxy_auc_HP)#
                        #aucXY.star1.A[b,(cc+6)] <- mean(Sxy_auc_param)#
                     }#
                     else {#
                        aucXY.star1.B[b,(cc+3)] <- mean(Sxy_auc_HP)#
                        #aucXY.star1.B[b,(cc+6)] <- mean(Sxy_auc_param)#
                     }#
                  }#
                  if(nri) {#
                     cThreshY_curr <- ( log(ctrlsRisk.star$rxCohort/(1-ctrlsRisk.star$rxCohort)) - cThreshY)/mod_cc.star$coeff[5]#
                     currEvent <- 2*mean( Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(ctrlsRiskSub.star)+nd)), sxy] > ccCases.star$rxCohort ) - 1#
                     #currNonevent_param <- 2*(mean( pnorm(cThreshY_curr, mean=rho*ctrlsRisk.star$X, sd=sqrt(1-rho^2)) )) - 1#
                     currNonevent_HP <- 2*(mean( F0.star( (cThreshY_curr - modYX_fitted.star)/sigma.star ) )) - 1#
                     if(methA & sxy==1){#
                        #nriEvent.star1.A[b,(cc+3)] <- nriEvent.star1.A[b,(cc+6)] <- currEvent#
                        #nriNonevent.star1.A[b,(cc+6)] <- currNonevent_param#
                        nriEvent.star1.A[b,(cc+3)] <- currEvent#
                        nriNonevent.star1.A[b,(cc+3)] <- currNonevent_HP#
                     }#
                     else {#
                        #nriEvent.star1.B[b,cc+3] <- nriEvent.star1.B[b,cc+6] <- currEvent#
                        #nriNonevent.star1.B[b,(cc+6)] <- currNonevent_param#
                        nriEvent.star1.B[b,cc+3] <- currEvent#
                        nriNonevent.star1.B[b,(cc+3)] <- currNonevent_HP#
                     }#
                  }#
                  if(idi) {#
                     cThresh <- seq(0,1,by=0.005)#
                     ##Parametric#
                     #quants <- vector(length=length(cThresh))#
                     #for(k in 1:length(cThresh)) {#
                     #   cThreshY_curr <- ( log(cThresh[k]/(1-cThresh[k])) - cThreshY)/mod_cc.star$coeff[5]#
                     #   quants[k] <- 1 - mean( pnorm(cThreshY_curr, mean=rho*ctrlsRisk.star$X, sd=sqrt(1-rho^2)) )#
                     #}#
                     #currNonevent_param <- mean(ctrlsRisk.star$rxCohort) - mean(quants)#
                     #Semi-parametric, HP#
                     quants <- vector(length=length(cThresh))#
                     for(k in 1:length(cThresh)) {#
                        cThreshY_curr <- ( log(cThresh[k]/(1-cThresh[k])) - cThreshY)/mod_cc.star$coeff[5]#
                        quants[k] <- 1 - mean( F0.star( (cThreshY_curr - modYX_fitted.star)/sigma.star ) )#
                     }#
                     currNonevent_HP <- mean(ctrlsRisk.star$rxCohort) - mean(quants)#
                     currEvent <- mean(Sxy.star[((nd*r+1):(nd*r+nd)), sxy]) - mean(casesRisk.star$rxCohort)#
                     if(methA & sxy==1){#
                        #idiEvent.star1.A[b,(cc+3)] <- idiEvent.star1.A[b,(cc+6)] <- currEvent#
                        #idiNonevent.star1.A[b,(cc+6)] <- currNonevent_param#
                        idiEvent.star1.A[b,(cc+3)] <- currEvent#
                        idiNonevent.star1.A[b,(cc+3)] <- currNonevent_HP#
                     }#
                     else {#
                        #idiEvent.star1.B[b,(cc+3)] <- idiEvent.star1.B[b,(cc+6)] <- currEvent#
                        #idiNonevent.star1.B[b,(cc+6)] <- currNonevent_param#
                        idiEvent.star1.B[b,(cc+3)] <- currEvent#
                        idiNonevent.star1.B[b,(cc+3)] <- currNonevent_HP#
                     }#
                  }#
                  if(tg) {#
                     cThreshY_curr <- ( log(prevCohort.star/(1-prevCohort.star)) - cThreshY)/mod_cc.star$coeff[5]#
                     currEvent <- mean(Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(ctrlsRiskSub.star)+nd)), sxy] > prevCohort.star) - mean(casesRisk.star$rxCohort > prevCohort.star)#
                     #currNonevent_param <- mean(ctrlsRisk.star$rxCohort > prevCohort.star) - 1 + mean( pnorm(cThreshY_curr, mean=rho*ctrlsRisk.star$X, sd=sqrt(1-rho^2)) )#
                     currNonevent_HP <- mean(ctrlsRisk.star$rxCohort > prevCohort.star) - 1 + mean( F0.star( (cThreshY_curr - modYX_fitted.star)/sigma.star ) )#
                     if(methA & sxy==1){#
                        #tgEvent.star1.A[b,(3+cc)] <- tgEvent.star1.A[b,(6+cc)] <- currEvent#
                        #tgNonevent.star1.A[b,cc+6] <- currNonevent_param#
                        tgEvent.star1.A[b,(3+cc)] <- currEvent#
                        tgNonevent.star1.A[b,(3+cc)] <- currNonevent_HP#
                     }#
                     else {#
                        #tgEvent.star1.B[b,(3+cc)] <- tgEvent.star1.B[b,(6+cc)] <- currEvent#
                        #tgNonevent.star1.B[b,(6+cc)] <- currNonevent_param#
                        tgEvent.star1.B[b,(3+cc)] <- currEvent#
                        tgNonevent.star1.B[b,(3+cc)] <- currNonevent_HP#
                     }#
                  }#
               } #sxy for loop#
            } #if semiparam#
            if(nonparam) {#
               if(ccSubs[cc]=="simple") {#
                  if(roc | auc) {#
                     ccD.star <<- ccSubset.star$dis#
                     SxyA.star <<- ccSubset.star$SxyA#
                     #SxyA <- Sxy[,1]#
                     rocResults <- comproc(d="ccD.star", markers="SxyA.star", roc=t, auc=T, nobstrap=T)#
                     aucXY.star1.A[b,cc] <- rocResults[1]#
                     rocXY.star1.A[b,cc] <- rocResults[2]#
                     SxyB.star <<- ccSubset.star$SxyB#
                     #SxyB <- Sxy[,2]#
                     rocResults <- comproc(d="ccD.star", markers="SxyB.star", roc=t, auc=T, nobstrap=T)#
                     aucXY.star1.B[b,cc] <- rocResults[1]#
                     rocXY.star1.B[b,cc] <- rocResults[2]#
                  }#
                  if(nri) {#
                     nriEvent.star1.A[b,cc] <- 2*mean( ccCases.star$SxyA > ccCases.star$rxCohort ) - 1#
                     nriNonevent.star1.A[b,cc] <- 1 - 2*mean( ccCtrls.star$SxyA > ccCtrls.star$rxCohort )#
                     nriEvent.star1.B[b,cc] <- 2*mean( ccCases.star$SxyB > ccCases.star$rxCohort )  - 1#
                     nriNonevent.star1.B[b,cc] <- 1 - 2*mean( ccCtrls.star$SxyB > ccCtrls.star$rxCohort )#
                  }#
                  if(idi) {#
                     idiEvent.star1.A[b,cc] <- mean(ccCases.star$SxyA) - mean(casesRisk.star$rxCohort)#
                     idiNonevent.star1.A[b,cc] <- mean(ctrlsRisk.star$rxCohort) - mean(ccCtrls.star$SxyA )#
                     idiEvent.star1.B[b,cc] <- mean(ccCases.star$SxyB) - mean(casesRisk.star$rxCohort)#
                     idiNonevent.star1.B[b,cc] <- mean(ctrlsRisk.star$rxCohort) - mean(ccCtrls.star$SxyB )#
                  }#
                  if(tg) {#
                     tgEvent.star1.A[b,cc] <- mean(ccCases.star$SxyA > prevCohort.star) - mean(casesRisk.star$rxCohort > prevCohort.star)#
                     tgNonevent.star1.A[b,cc] <- mean(ctrlsRisk.star$rxCohort > prevCohort.star) - mean(ccCtrls.star$SxyA > prevCohort.star)#
                     tgEvent.star1.B[b,cc] <- mean(ccCases.star$SxyB > prevCohort.star) - mean(casesRisk.star$rxCohort > prevCohort.star)#
                     tgNonevent.star1.B[b,cc] <- mean(ctrlsRisk.star$rxCohort > prevCohort.star) - mean(ccCtrls.star$SxyB > prevCohort.star)#
                  }#
               }#
               if(ccSubs[cc]=="freqMatch" | ccSubs[cc]=="hybrid") {#
                  #Calculate fpfsXY#
                  Nbins <- unlist( lapply(sort(unique(XctrlBins.star)), FUN=function(x){sum(XctrlBins.star==x)} ) )#
                  binWeights <- Nbins/nrow(ctrlsRisk.star)#
                  nbins <- unlist( lapply(sort(unique(XctrlBins.star)), FUN=function(x){sum(XctrlSubBins.star==x)} ) )#
                  if(min(nbins) == 0) {#
                     print("Empty bins")#
                     countEmptyBins[cc] <- countEmptyBins[cc] + 1#
                  }#
                  else{ #
                     for(sxy in 1:ncol(Sxy.star)) {#
                        #Estimate case and ctrl popn distns of S(X,Y) using book, ch.2#
                        if(roc) { #
                           cThresh <- seq(max(Sxy.star[1:(nrow(ctrlsRiskSub.star)),sxy])+.001,min(Sxy.star[1:(nrow(ctrlsRiskSub.star)),sxy])-.001,by=-0.001)#
                           #cThresh <- seq(max(Sxy[,sxy])+.001,min(Sxy[,sxy])-.001,by=-0.001)#
                           #cThresh <- seq(max(ccCtrls$SxyA)+.001,min(ccCtrls$SxyA)-.001,by=-0.001)#
                           binSums <- rep(0,numBins)#
                           for(k in 1:length(cThresh)) {#
                              binSums <- unlist( lapply( seq(1:numBins), #
                                 function(x){ sum(Sxy.star[which(XctrlSubBins.star==x),sxy] <= cThresh[k]) } ) )#
                              quant <- sum(binWeights * binSums/nbins)#
                              if(quant >= 1-t) currQuant <- quant#
                              if(k<length(cThresh) & quant < (1-t)) {#
                                 #quantUsed_star[b,cc] <- currQuant#
                                 #quantUsed_non[cc] <- currQuant#
                                 break#
                              }#
                           }#
                           cFPF0.05 <- ifelse(k==1, NA, cThresh[k-1])#
                           #quantJustAfter_star[b,cc] <- quant#
                           if(methA & sxy==1)#
                              rocXY.star1.A[b,cc] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(Sxy.star))),sxy] <= cFPF0.05))#
                           else#
                              rocXY.star1.B[b,cc] <- ifelse(is.na(cFPF0.05), NA, 1 - mean(Sxy.star[(nrow(ctrlsRiskSub.star)+1):(nrow(Sxy.star)),sxy] <= cFPF0.05))#
                        }#
                        if(auc) {#
                           Sxy_auc <- vector(length=nd)#
                           for(nd_i in 1:nd) {#
                              binSums <- unlist( lapply( seq(1:numBins), function(x){ sum(Sxy.star[which(XctrlSubBins.star==x),sxy] > Sxy.star[nd_i + nrow(ctrlsRiskSub.star), sxy] ) } ) )#
                              Sxy_auc[nd_i] <- sum(binWeights * binSums/nbins)#
                           }#
                           currAuc <- 1 - mean(Sxy_auc)#
                           if(methA & sxy==1) aucXY.star1.A[b,cc] <- currAuc#
                           else aucXY.star1.B[b,cc] <- currAuc#
                        }#
                        if(nri) {#
                           currEvent <- 1 - 2*mean( Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(ctrlsRiskSub.star)+nd)), sxy] <= ccCases.star$rxCohort )#
                           #currEvent <- 2*mean( Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(ctrlsRiskSub.star)+nd)), sxy] > ccCases.star$rxCohort ) - 1#
                           binMeans <- unlist( lapply( seq(1:numBins), function(x){mean( Sxy.star[which(XctrlSubBins.star==x), sxy] > ccCtrls.star$rxCohort[which(XctrlSubBins.star==x)] )} ) )#
                           currNonevent <- 1 - 2*sum(binWeights * binMeans)#
                           if(methA & sxy==1){#
                              nriEvent.star1.A[b,cc] <- currEvent#
                              nriNonevent.star1.A[b,cc] <- currNonevent#
                           }#
                           else {#
                              nriEvent.star1.B[b,cc] <- currEvent#
                              nriNonevent.star1.B[b,cc] <- currNonevent#
                           }#
                        }#
                        if(idi) {#
                           currEvent <- mean(Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(ctrlsRiskSub.star)+nd)), sxy]) - mean(casesRisk.star$rxCohort)#
                           binMeans <- unlist( lapply( seq(1:numBins), function(x){mean( Sxy.star[which(XctrlSubBins.star==x), sxy] )} ) )#
                           currNonevent <- mean(ctrlsRisk.star$rxCohort) - sum(binWeights * binMeans)#
                           if(methA & sxy==1){#
                              idiEvent.star1.A[b,cc] <- currEvent#
                              idiNonevent.star1.A[b,cc] <- currNonevent#
                           }#
                           else {#
                              idiEvent.star1.B[b,cc] <- currEvent#
                              idiNonevent.star1.B[b,cc] <- currNonevent#
                           }#
                        }#
                        if(tg) {#
                           currEvent <- mean(Sxy.star[((nrow(ctrlsRiskSub.star)+1):(nrow(ctrlsRiskSub.star)+nd)), sxy] > prevCohort.star) - mean(casesRisk.star$rxCohort > prevCohort.star)#
                           binMeans <- unlist( lapply( seq(1:numBins), function(x){mean( Sxy.star[which(XctrlSubBins.star==x), sxy] > prevCohort.star )} ) )#
                           currNonevent <- mean(ctrlsRisk.star$rxCohort > prevCohort.star) - sum(binWeights * binMeans)#
                           if(methA & sxy==1){#
                              tgEvent.star1.A[b,cc] <- currEvent#
                              tgNonevent.star1.A[b,cc] <- currNonevent#
                           }#
                           else {#
                              tgEvent.star1.B[b,cc] <- currEvent#
                              tgNonevent.star1.B[b,cc] <- currNonevent#
                           }#
                        }#
                        # #Figure out this issue in comproc#
                        # #   rocX <- comproc(d="cohort$dis", markers="cohort$X", roc=0.05, nobstrap=T)#
                        # #   rocXY <- comproc(d="ccSubset$dis", markers="Sxy", roc=0.05, nobstrap=T)#
                     } #sxy for loop#
                  } #else#
               } #if matched#
            } #if nonparam#
         } #b in 1:nboot for loop#
      } #cc for loop#
      #####Bootstrap coverage#
      #rocX_bootCov[s] <-  #
      #aucX_bootCov[s,] <- vector(length=nSimul)#
      AB <- c("A","B")#
      for(ab in 1:length(AB)) {#
         for(m in 1:length(measures)) {#
            if(measures[m]=="roc" | measures[m]=="auc") {#
               submeasures <- c("X","XY","Delta")#
               currMat1 <- eval(parse(text=paste(measures[m],"X.star1",sep="")))#
               currMat2 <- eval(parse(text=paste(measures[m],"XY.star1.",AB[ab],sep="")))#
               currMat3 <- currMat2 - currMat1#
            }#
            if(measures[m]=="nri" | measures[m]=="idi" | measures[m]=="tg") {#
               submeasures <- c("Event","Nonevent","")#
               currMat1 <- eval(parse(text=paste(measures[m],"Event.star1.",AB[ab],sep="")))#
               currMat2 <- eval(parse(text=paste(measures[m],"Nonevent.star1.",AB[ab],sep="")))#
               currMat3 <- currMat2 + currMat1#
            }#
            #Coverage#
            currRes1_bootCov <- eval(parse(text=paste(measures[m],submeasures[1],"_",AB[ab],"_bootCov",sep="")))#
            currRes2_bootCov <- eval(parse(text=paste(measures[m],submeasures[2],"_",AB[ab],"_bootCov",sep="")))#
            currRes3_bootCov <- eval(parse(text=paste(measures[m],submeasures[3],"_",AB[ab],"_bootCov",sep="")))#
            currTruth1 <- eval(parse(text=paste(measures[m],"Res[1,1]",sep="")))#
            currTruth2 <- eval(parse(text=paste(measures[m],"Res[1,3]",sep="")))#
            currTruth3 <- eval(parse(text=paste(measures[m],"Res[1,5]",sep="")))#
            currRes1_bootCov[s,] <- apply(currMat1, 2, function(x) isInInterval(x, currTruth1 ))#
            currRes2_bootCov[s,] <- apply(currMat2, 2, function(x) isInInterval(x, currTruth2 ))#
            currRes3_bootCov[s,] <- apply(currMat3, 2, function(x) isInInterval(x, currTruth3 ))#
            assign(paste(measures[m],submeasures[1],"_",AB[ab],"_bootCov",sep=""), currRes1_bootCov)#
            assign(paste(measures[m],submeasures[2],"_",AB[ab],"_bootCov",sep=""), currRes2_bootCov)#
            assign(paste(measures[m],submeasures[3],"_",AB[ab],"_bootCov",sep=""), currRes3_bootCov)#
            #IQR#
            currRes1_bootIQR <- eval(parse(text=paste(measures[m],submeasures[1],"_",AB[ab],"_bootIQR",sep="")))#
            currRes2_bootIQR <- eval(parse(text=paste(measures[m],submeasures[2],"_",AB[ab],"_bootIQR",sep="")))#
            currRes3_bootIQR <- eval(parse(text=paste(measures[m],submeasures[3],"_",AB[ab],"_bootIQR",sep="")))#
            currRes1_bootIQR[s,] <- apply(currMat1, 2, function(x) diff(quantile(x, p=c(0.25,0.75), na.rm=T)))#
            currRes2_bootIQR[s,] <- apply(currMat2, 2, function(x) diff(quantile(x, p=c(0.25,0.75), na.rm=T)))#
            currRes3_bootIQR[s,] <- apply(currMat3, 2, function(x) diff(quantile(x, p=c(0.25,0.75), na.rm=T)))#
            assign(paste(measures[m],submeasures[1],"_",AB[ab],"_bootIQR",sep=""), currRes1_bootIQR)#
            assign(paste(measures[m],submeasures[2],"_",AB[ab],"_bootIQR",sep=""), currRes2_bootIQR)#
            assign(paste(measures[m],submeasures[3],"_",AB[ab],"_bootIQR",sep=""), currRes3_bootIQR)#
            #Mean#
            currRes1_bootMean <- eval(parse(text=paste(measures[m],submeasures[1],"_",AB[ab],"_bootMean",sep="")))#
            currRes2_bootMean <- eval(parse(text=paste(measures[m],submeasures[2],"_",AB[ab],"_bootMean",sep="")))#
            currRes3_bootMean <- eval(parse(text=paste(measures[m],submeasures[3],"_",AB[ab],"_bootMean",sep="")))#
            currRes1_bootMean[s,] <- apply(currMat1, 2, mean, na.rm=T )#
            currRes2_bootMean[s,] <- apply(currMat2, 2, mean, na.rm=T )#
            currRes3_bootMean[s,] <- apply(currMat3, 2, mean, na.rm=T )#
            assign(paste(measures[m],submeasures[1],"_",AB[ab],"_bootMean",sep=""), currRes1_bootMean)#
            assign(paste(measures[m],submeasures[2],"_",AB[ab],"_bootMean",sep=""), currRes2_bootMean)#
            assign(paste(measures[m],submeasures[3],"_",AB[ab],"_bootMean",sep=""), currRes3_bootMean)#
            #Std Error#
            currRes1_bootSE <- eval(parse(text=paste(measures[m],submeasures[1],"_",AB[ab],"_bootSE",sep="")))#
            currRes2_bootSE <- eval(parse(text=paste(measures[m],submeasures[2],"_",AB[ab],"_bootSE",sep="")))#
            currRes3_bootSE <- eval(parse(text=paste(measures[m],submeasures[3],"_",AB[ab],"_bootSE",sep="")))#
            currRes1_bootSE[s,] <- apply(currMat1, 2, sd, na.rm=T )#
            currRes2_bootSE[s,] <- apply(currMat2, 2, sd, na.rm=T )#
            currRes3_bootSE[s,] <- apply(currMat3, 2, sd, na.rm=T )#
            assign(paste(measures[m],submeasures[1],"_",AB[ab],"_bootSE",sep=""), currRes1_bootSE)#
            assign(paste(measures[m],submeasures[2],"_",AB[ab],"_bootSE",sep=""), currRes2_bootSE)#
            assign(paste(measures[m],submeasures[3],"_",AB[ab],"_bootSE",sep=""), currRes3_bootSE)#
         } #measures#
      } #ab#
   } #nSimul for loop#
   #rocBootResIQR <- aucBootResIQR <- tgBootResIQR <- nriBootResIQR <- idiBootResIQR <- matrix(nrow=12, ncol=9)#
   for(m in 1:length(measures)) {#
      if(measures[m]=="roc" | measures[m]=="auc") {#
         submeasures <- c("X","XY","Delta")#
         currMat1A_sim <- eval(parse(text=paste(measures[m],submeasures[1],"_A_star",sep="")))#
         currMat1A_sim <- currMat1B_sim <- matrix(rep(currMat1A_sim[,1], ncol(currMat1A_sim)), nrow=nrow(currMat1A_sim))#
         currMat2A_sim <- eval(parse(text=paste(measures[m],submeasures[2],"_A_star",sep="")))#
         currMat2B_sim <- eval(parse(text=paste(measures[m],submeasures[2],"_B_star",sep="")))#
         currMat3A_sim <- currMat2A_sim - currMat1A_sim#
         currMat3B_sim <- currMat2B_sim - currMat1B_sim#
         currMat1A_bootIQR <- currMat1B_bootIQR <- eval(parse(text=paste(measures[m],submeasures[1],"_A_bootIQR",sep="")))#
         currMat1A_bootCov <- currMat1B_bootCov <- eval(parse(text=paste(measures[m],submeasures[1],"_A_bootCov",sep="")))#
      }#
      if(measures[m]=="nri" | measures[m]=="idi" | measures[m]=="tg") {#
         submeasures <- c("Event","Nonevent","")#
         currMat1A_sim <- eval(parse(text=paste(measures[m],submeasures[1],"_A_star",sep="")))#
         currMat1B_sim <- eval(parse(text=paste(measures[m],submeasures[1],"_B_star",sep="")))#
         currMat2A_sim <- eval(parse(text=paste(measures[m],submeasures[2],"_A_star",sep="")))#
         currMat2B_sim <- eval(parse(text=paste(measures[m],submeasures[2],"_B_star",sep="")))#
         currMat3A_sim <- currMat2A_sim + currMat1A_sim#
         currMat3B_sim <- currMat2B_sim + currMat1B_sim#
         currMat1A_bootIQR <- eval(parse(text=paste(measures[m],submeasures[1],"_A_bootIQR",sep="")))#
         currMat1B_bootIQR <- eval(parse(text=paste(measures[m],submeasures[1],"_B_bootIQR",sep="")))#
         currMat1A_bootCov <- eval(parse(text=paste(measures[m],submeasures[1],"_A_bootCov",sep="")))#
         currMat1B_bootCov <- eval(parse(text=paste(measures[m],submeasures[1],"_B_bootCov",sep="")))#
      }#
      currMat2A_bootIQR <- eval(parse(text=paste(measures[m],submeasures[2],"_A_bootIQR",sep="")))#
      currMat2B_bootIQR <- eval(parse(text=paste(measures[m],submeasures[2],"_B_bootIQR",sep="")))#
      currMat3A_bootIQR <- eval(parse(text=paste(measures[m],submeasures[3],"_A_bootIQR",sep="")))#
      currMat3B_bootIQR <- eval(parse(text=paste(measures[m],submeasures[3],"_B_bootIQR",sep="")))#
      currMat2A_bootCov <- eval(parse(text=paste(measures[m],submeasures[2],"_A_bootCov",sep="")))#
      currMat2B_bootCov <- eval(parse(text=paste(measures[m],submeasures[2],"_B_bootCov",sep="")))#
      currMat3A_bootCov <- eval(parse(text=paste(measures[m],submeasures[3],"_A_bootCov",sep="")))#
      currMat3B_bootCov <- eval(parse(text=paste(measures[m],submeasures[3],"_B_bootCov",sep="")))#
      ###Bootstrap IQR Results#
      currBootResIQR <- matrix(nrow=12, ncol=9)#
      currBootResIQR[1,] <- apply(currMat1A_sim, 2, function(x) diff(quantile(x, p=c(0.25,0.75), na.rm=T)))#
      currBootResIQR[3,] <- apply(currMat1B_sim, 2, function(x) diff(quantile(x, p=c(0.25,0.75), na.rm=T)))#
      currBootResIQR[5,] <- apply(currMat2A_sim, 2, function(x) diff(quantile(x, p=c(0.25,0.75), na.rm=T)))#
      currBootResIQR[7,] <- apply(currMat2B_sim, 2, function(x) diff(quantile(x, p=c(0.25,0.75), na.rm=T)))#
      currBootResIQR[9,] <- apply(currMat3A_sim, 2, function(x) diff(quantile(x, p=c(0.25,0.75), na.rm=T)))#
      currBootResIQR[11,] <- apply(currMat3B_sim, 2, function(x) diff(quantile(x, p=c(0.25,0.75), na.rm=T)))#
      currBootResIQR[2,] <- apply(currMat1A_bootIQR, 2, mean, na.rm=T)#
      currBootResIQR[4,] <- apply(currMat1B_bootIQR, 2, mean, na.rm=T)#
      currBootResIQR[6,] <- apply(currMat2A_bootIQR, 2, mean, na.rm=T)#
      currBootResIQR[8,] <- apply(currMat2B_bootIQR, 2, mean, na.rm=T)#
      currBootResIQR[10,] <- apply(currMat3A_bootIQR, 2, mean, na.rm=T)#
      currBootResIQR[12,] <- apply(currMat3B_bootIQR, 2, mean, na.rm=T)#
      rownamesHalf <- c("_sim_A", "_boot_A", "_sim_B","_boot_B")#
      rownames(currBootResIQR) <- as.vector(sapply(submeasures, function(x) paste(measures[m],x,rownamesHalf,sep="") ))#
      colnames(currBootResIQR) <- c("unmatch_non","freq_non","hybrid_non","unmatch_semi","freq_semi","hybrid_semi","unmatch_param","freq_param","hybrid_param")#
      assign(paste(measures[m],"BootResIQR",sep=""), currBootResIQR)#
      ###Bootstrap Coverage Results#
      currBootResCov <- matrix(nrow=6, ncol=9)#
      currBootResCov[1,] <- apply(currMat1A_bootCov, 2, mean, na.rm=T)#
      currBootResCov[2,] <- apply(currMat1B_bootCov, 2, mean, na.rm=T)#
      currBootResCov[3,] <- apply(currMat2A_bootCov, 2, mean, na.rm=T)#
      currBootResCov[4,] <- apply(currMat2B_bootCov, 2, mean, na.rm=T)#
      currBootResCov[5,] <- apply(currMat3A_bootCov, 2, mean, na.rm=T)#
      currBootResCov[6,] <- apply(currMat3B_bootCov, 2, mean, na.rm=T)#
      rownamesHalf <- c("_boot_A", "_boot_B")#
      rownames(currBootResCov) <- as.vector(sapply(submeasures, function(x) paste(measures[m],x,rownamesHalf,sep="") ))#
      colnames(currBootResCov) <- c("unmatch_non","freq_non","hybrid_non","unmatch_semi","freq_semi","hybrid_semi","unmatch_param","freq_param","hybrid_param")#
      assign(paste(measures[m],"BootResCov",sep=""), currBootResCov)#
   }
save.image("/Users/aasthaa/Dropbox/Dissertation/2-stage/bstrapLDApaper_rho05_imputeWithinStrata_eachBstrapRep.Rdata")
rocBootResCov
aucBootResCov
nriBootResCov
tgBootResCov
ls()
rm(list=ls())
Y_db <- rnorm(100, mean=0, sd=2)
X_db <- rnorm(100, mean=3, sd=3)
modYX <- lm(Y_db ~ X_db)
mu_cc <- modYX$fitted.values
sigma <- sd(modYX$residuals)
(Y_db-mu_cc)/sigma
modYX$residuals/sigma
(Y_db-mu_cc)/sigma - modYX$residuals/sigma
range((Y_db-mu_cc)/sigma - modYX$residuals/sigma)
mean((Y_db-mu_cc)/sigma - modYX$residuals/sigma)
ls()
rm(list=ls())
nonparametric#
for(cc in 1:length(ccSubs)) { #
   results <- NULL#
   for(m in 1:length(measures)) {#
   	  currEsts.full <- (eval(parse(text=paste(measures[m],"Res_orig_full",sep=""))))[c(1,3,5),1]#
      currEstsA.2phase <- (eval(parse(text=paste(measures[m],"ResA_orig_2phase",sep=""))))[c(1,3,5),]#
      currEstsB.2phase <- (eval(parse(text=paste(measures[m],"ResB_orig_2phase",sep=""))))[c(1,3,5),]#
#
      if(measures[m]=="roc" | measures[m]=="auc" | measures[m]=="hrc" | measures[m]=="b") {#
   	     currEsts.full <- currEsts.full[2] - currEsts.full[1]#
         currEstsA.2phase <- currEstsA.2phase[2,] - currEstsA.2phase[1,]#
         currEstsB.2phase <- currEstsB.2phase[2,] - currEstsB.2phase[1,]#
#
         currBstrap1A.2phase <- currBstrap1B.2phase <- eval(parse(text=paste(measures[m],"X.star2phase",sep="")))#
         currBstrap2A.2phase <- eval(parse(text=paste(measures[m],"XY.star2phase.A",sep="")))#
         currBstrap3A.2phase <- currBstrap2A.2phase - currBstrap1A.2phase#
         currBstrap2B.2phase <- eval(parse(text=paste(measures[m],"XY.star2phase.B",sep="")))#
         currBstrap3B.2phase <- currBstrap2B.2phase - currBstrap1B.2phase#
      }#
      else if(measures[m]=="rocinv" | measures[m]=="hrn") {#
   	     currEsts.full <- currEsts.full[1] - currEsts.full[2]#
         currEstsA.2phase <- currEstsA.2phase[1,] - currEstsA.2phase[2,]#
         currEstsB.2phase <- currEstsB.2phase[1,] - currEstsB.2phase[2,]#
#
         currBstrap1A.2phase <- currBstrap1B.2phase <- eval(parse(text=paste(measures[m],"X.star2phase",sep="")))#
         currBstrap2A.2phase <- eval(parse(text=paste(measures[m],"XY.star2phase.A",sep="")))#
         currBstrap3A.2phase <- currBstrap2A.2phase - currBstrap1A.2phase#
         currBstrap2B.2phase <- eval(parse(text=paste(measures[m],"XY.star2phase.B",sep="")))#
         currBstrap3B.2phase <- currBstrap2B.2phase - currBstrap1B.2phase#
      }      #
      else if(measures[m]=="nri" | measures[m]=="tg" | measures[m]=="idi") {#
         currEsts.full <- currEsts.full[2] + currEsts.full[1]#
         currEstsA.2phase <- currEstsA.2phase[2,] + currEstsA.2phase[1,]#
         currEstsB.2phase <- currEstsB.2phase[2,] + currEstsB.2phase[1,]#
#
         currBstrap1A.2phase <- eval(parse(text=paste(measures[m],"Event.star2phase.A",sep="")))#
         currBstrap2A.2phase <- eval(parse(text=paste(measures[m],"Nonevent.star2phase.A",sep="")))#
         currBstrap3A.2phase <- currBstrap2A.2phase + currBstrap1A.2phase#
         currBstrap1B.2phase <- eval(parse(text=paste(measures[m],"Event.star2phase.B",sep="")))#
         currBstrap2B.2phase <- eval(parse(text=paste(measures[m],"Nonevent.star2phase.B",sep="")))#
         currBstrap3B.2phase <- currBstrap2B.2phase + currBstrap1B.2phase#
      }#
      sdA <- data.frame(t(as.matrix( apply(currBstrap3A.2phase, 2, sd, na.rm=T), nrow=1)))#
      sdB <- data.frame(t(as.matrix( apply(currBstrap3B.2phase, 2, sd, na.rm=T), nrow=1)))      #
      ciA <- sapply(seq(ncol(currBstrap3A.2phase)), function(x){#
         paste( "(", round((currEstsA.2phase[x]) - 1.96*(sdA[x]),3), ", ", round((currEstsA.2phase[x]) + 1.96*(sdA[x]),3), ")", sep="") })#
      ciA <- data.frame(t(as.matrix(ciA, nrow=1)))#
      ciB <- sapply(seq(ncol(currBstrap3B.2phase)), function(x){#
         paste( "(", round((currEstsB.2phase[x]) - 1.96*(sdB[x]),3), ", ", round((currEstsB.2phase[x]) + 1.96*(sdB[x]),3), ")", sep="") })#
      ciB <- data.frame(t(as.matrix(ciB, nrow=1)))#
      names(ciA) <- names(ciB) <- names(currEstsA.2phase)#
#
      if(cc==1) {#
         currRow <- c( round(currEsts.full,3),#
            round(currEstsA.2phase$unmatch_non,3), round(sdA$unmatch_non,3), as.character(ciA$unmatch_non),#
            round(currEstsB.2phase$unmatch_non,3), round(sdB$unmatch_non,3), as.character(ciB$unmatch_non) )#
      }#
      if(cc==2) {#
         currRow <- c( round(currEsts.full,3),#
            round(currEstsA.2phase$freq_non,3), round(sdA$freq_non,3), as.character(ciA$freq_non),#
            round(currEstsB.2phase$freq_non,3), round(sdB$freq_non,3), as.character(ciB$freq_non) )#
      }#
      results <- rbind(results, currRow)#
   }#
   rownames(results) <- seq(1:nrow(results))#
   print(xtable(results, digits=rep(0,1+ncol(results))), include.rownames=F)#
}
measures <- c("hrc","hrn","b","rocinv","roc","auc","idi","tg","nri")#
#
#nonparametric#
for(cc in 1:length(ccSubs)) { #
   results <- NULL#
   for(m in 1:length(measures)) {#
   	  currEsts.full <- (eval(parse(text=paste(measures[m],"Res_orig_full",sep=""))))[c(1,3,5),1]#
      currEstsA.2phase <- (eval(parse(text=paste(measures[m],"ResA_orig_2phase",sep=""))))[c(1,3,5),]#
      currEstsB.2phase <- (eval(parse(text=paste(measures[m],"ResB_orig_2phase",sep=""))))[c(1,3,5),]#
#
      if(measures[m]=="roc" | measures[m]=="auc" | measures[m]=="hrc" | measures[m]=="b") {#
   	     currEsts.full <- currEsts.full[2] - currEsts.full[1]#
         currEstsA.2phase <- currEstsA.2phase[2,] - currEstsA.2phase[1,]#
         currEstsB.2phase <- currEstsB.2phase[2,] - currEstsB.2phase[1,]#
#
         currBstrap1A.2phase <- currBstrap1B.2phase <- eval(parse(text=paste(measures[m],"X.star2phase",sep="")))#
         currBstrap2A.2phase <- eval(parse(text=paste(measures[m],"XY.star2phase.A",sep="")))#
         currBstrap3A.2phase <- currBstrap2A.2phase - currBstrap1A.2phase#
         currBstrap2B.2phase <- eval(parse(text=paste(measures[m],"XY.star2phase.B",sep="")))#
         currBstrap3B.2phase <- currBstrap2B.2phase - currBstrap1B.2phase#
      }#
      else if(measures[m]=="rocinv" | measures[m]=="hrn") {#
   	     currEsts.full <- currEsts.full[1] - currEsts.full[2]#
         currEstsA.2phase <- currEstsA.2phase[1,] - currEstsA.2phase[2,]#
         currEstsB.2phase <- currEstsB.2phase[1,] - currEstsB.2phase[2,]#
#
         currBstrap1A.2phase <- currBstrap1B.2phase <- eval(parse(text=paste(measures[m],"X.star2phase",sep="")))#
         currBstrap2A.2phase <- eval(parse(text=paste(measures[m],"XY.star2phase.A",sep="")))#
         currBstrap3A.2phase <- currBstrap2A.2phase - currBstrap1A.2phase#
         currBstrap2B.2phase <- eval(parse(text=paste(measures[m],"XY.star2phase.B",sep="")))#
         currBstrap3B.2phase <- currBstrap2B.2phase - currBstrap1B.2phase#
      }      #
      else if(measures[m]=="nri" | measures[m]=="tg" | measures[m]=="idi") {#
         currEsts.full <- currEsts.full[2] + currEsts.full[1]#
         currEstsA.2phase <- currEstsA.2phase[2,] + currEstsA.2phase[1,]#
         currEstsB.2phase <- currEstsB.2phase[2,] + currEstsB.2phase[1,]#
#
         currBstrap1A.2phase <- eval(parse(text=paste(measures[m],"Event.star2phase.A",sep="")))#
         currBstrap2A.2phase <- eval(parse(text=paste(measures[m],"Nonevent.star2phase.A",sep="")))#
         currBstrap3A.2phase <- currBstrap2A.2phase + currBstrap1A.2phase#
         currBstrap1B.2phase <- eval(parse(text=paste(measures[m],"Event.star2phase.B",sep="")))#
         currBstrap2B.2phase <- eval(parse(text=paste(measures[m],"Nonevent.star2phase.B",sep="")))#
         currBstrap3B.2phase <- currBstrap2B.2phase + currBstrap1B.2phase#
      }#
      sdA <- data.frame(t(as.matrix( apply(currBstrap3A.2phase, 2, sd, na.rm=T), nrow=1)))#
      sdB <- data.frame(t(as.matrix( apply(currBstrap3B.2phase, 2, sd, na.rm=T), nrow=1)))      #
      ciA <- sapply(seq(ncol(currBstrap3A.2phase)), function(x){#
         paste( "(", round((currEstsA.2phase[x]) - 1.96*(sdA[x]),3), ", ", round((currEstsA.2phase[x]) + 1.96*(sdA[x]),3), ")", sep="") })#
      ciA <- data.frame(t(as.matrix(ciA, nrow=1)))#
      ciB <- sapply(seq(ncol(currBstrap3B.2phase)), function(x){#
         paste( "(", round((currEstsB.2phase[x]) - 1.96*(sdB[x]),3), ", ", round((currEstsB.2phase[x]) + 1.96*(sdB[x]),3), ")", sep="") })#
      ciB <- data.frame(t(as.matrix(ciB, nrow=1)))#
      names(ciA) <- names(ciB) <- names(currEstsA.2phase)#
#
      if(cc==1) {#
         currRow <- c( round(currEsts.full,3),#
            round(currEstsA.2phase$unmatch_non,3), round(sdA$unmatch_non,3), as.character(ciA$unmatch_non),#
            round(currEstsB.2phase$unmatch_non,3), round(sdB$unmatch_non,3), as.character(ciB$unmatch_non) )#
      }#
      if(cc==2) {#
         currRow <- c( round(currEsts.full,3),#
            round(currEstsA.2phase$freq_non,3), round(sdA$freq_non,3), as.character(ciA$freq_non),#
            round(currEstsB.2phase$freq_non,3), round(sdB$freq_non,3), as.character(ciB$freq_non) )#
      }#
      results <- rbind(results, currRow)#
   }#
   rownames(results) <- seq(1:nrow(results))#
   print(xtable(results, digits=rep(0,1+ncol(results))), include.rownames=F)#
}
library(xtable)
measures <- c("hrc","hrn","b","rocinv","roc","auc","idi","tg","nri")#
#
#nonparametric#
for(cc in 1:length(ccSubs)) { #
   results <- NULL#
   for(m in 1:length(measures)) {#
   	  currEsts.full <- (eval(parse(text=paste(measures[m],"Res_orig_full",sep=""))))[c(1,3,5),1]#
      currEstsA.2phase <- (eval(parse(text=paste(measures[m],"ResA_orig_2phase",sep=""))))[c(1,3,5),]#
      currEstsB.2phase <- (eval(parse(text=paste(measures[m],"ResB_orig_2phase",sep=""))))[c(1,3,5),]#
#
      if(measures[m]=="roc" | measures[m]=="auc" | measures[m]=="hrc" | measures[m]=="b") {#
   	     currEsts.full <- currEsts.full[2] - currEsts.full[1]#
         currEstsA.2phase <- currEstsA.2phase[2,] - currEstsA.2phase[1,]#
         currEstsB.2phase <- currEstsB.2phase[2,] - currEstsB.2phase[1,]#
#
         currBstrap1A.2phase <- currBstrap1B.2phase <- eval(parse(text=paste(measures[m],"X.star2phase",sep="")))#
         currBstrap2A.2phase <- eval(parse(text=paste(measures[m],"XY.star2phase.A",sep="")))#
         currBstrap3A.2phase <- currBstrap2A.2phase - currBstrap1A.2phase#
         currBstrap2B.2phase <- eval(parse(text=paste(measures[m],"XY.star2phase.B",sep="")))#
         currBstrap3B.2phase <- currBstrap2B.2phase - currBstrap1B.2phase#
      }#
      else if(measures[m]=="rocinv" | measures[m]=="hrn") {#
   	     currEsts.full <- currEsts.full[1] - currEsts.full[2]#
         currEstsA.2phase <- currEstsA.2phase[1,] - currEstsA.2phase[2,]#
         currEstsB.2phase <- currEstsB.2phase[1,] - currEstsB.2phase[2,]#
#
         currBstrap1A.2phase <- currBstrap1B.2phase <- eval(parse(text=paste(measures[m],"X.star2phase",sep="")))#
         currBstrap2A.2phase <- eval(parse(text=paste(measures[m],"XY.star2phase.A",sep="")))#
         currBstrap3A.2phase <- currBstrap2A.2phase - currBstrap1A.2phase#
         currBstrap2B.2phase <- eval(parse(text=paste(measures[m],"XY.star2phase.B",sep="")))#
         currBstrap3B.2phase <- currBstrap2B.2phase - currBstrap1B.2phase#
      }      #
      else if(measures[m]=="nri" | measures[m]=="tg" | measures[m]=="idi") {#
         currEsts.full <- currEsts.full[2] + currEsts.full[1]#
         currEstsA.2phase <- currEstsA.2phase[2,] + currEstsA.2phase[1,]#
         currEstsB.2phase <- currEstsB.2phase[2,] + currEstsB.2phase[1,]#
#
         currBstrap1A.2phase <- eval(parse(text=paste(measures[m],"Event.star2phase.A",sep="")))#
         currBstrap2A.2phase <- eval(parse(text=paste(measures[m],"Nonevent.star2phase.A",sep="")))#
         currBstrap3A.2phase <- currBstrap2A.2phase + currBstrap1A.2phase#
         currBstrap1B.2phase <- eval(parse(text=paste(measures[m],"Event.star2phase.B",sep="")))#
         currBstrap2B.2phase <- eval(parse(text=paste(measures[m],"Nonevent.star2phase.B",sep="")))#
         currBstrap3B.2phase <- currBstrap2B.2phase + currBstrap1B.2phase#
      }#
      sdA <- data.frame(t(as.matrix( apply(currBstrap3A.2phase, 2, sd, na.rm=T), nrow=1)))#
      sdB <- data.frame(t(as.matrix( apply(currBstrap3B.2phase, 2, sd, na.rm=T), nrow=1)))      #
      ciA <- sapply(seq(ncol(currBstrap3A.2phase)), function(x){#
         paste( "(", round((currEstsA.2phase[x]) - 1.96*(sdA[x]),3), ", ", round((currEstsA.2phase[x]) + 1.96*(sdA[x]),3), ")", sep="") })#
      ciA <- data.frame(t(as.matrix(ciA, nrow=1)))#
      ciB <- sapply(seq(ncol(currBstrap3B.2phase)), function(x){#
         paste( "(", round((currEstsB.2phase[x]) - 1.96*(sdB[x]),3), ", ", round((currEstsB.2phase[x]) + 1.96*(sdB[x]),3), ")", sep="") })#
      ciB <- data.frame(t(as.matrix(ciB, nrow=1)))#
      names(ciA) <- names(ciB) <- names(currEstsA.2phase)#
#
      if(cc==1) {#
         currRow <- c( round(currEsts.full,3),#
            round(currEstsA.2phase$unmatch_non,3), round(sdA$unmatch_non,3), as.character(ciA$unmatch_non),#
            round(currEstsB.2phase$unmatch_non,3), round(sdB$unmatch_non,3), as.character(ciB$unmatch_non) )#
      }#
      if(cc==2) {#
         currRow <- c( round(currEsts.full,3),#
            round(currEstsA.2phase$freq_non,3), round(sdA$freq_non,3), as.character(ciA$freq_non),#
            round(currEstsB.2phase$freq_non,3), round(sdB$freq_non,3), as.character(ciB$freq_non) )#
      }#
      results <- rbind(results, currRow)#
   }#
   rownames(results) <- seq(1:nrow(results))#
   print(xtable(results, digits=rep(0,1+ncol(results))), include.rownames=F)#
}
measures <- c("hrc","hrn","b","rocinv","roc","auc","idi","tg","nri")#
estProc <- c("NP","SP")#
#
for(e in 1:length(estProc)) {#
for(cc in 1:length(ccSubs)) { #
   results <- NULL#
   for(m in 1:length(measures)) {#
   	  currEsts.full <- (eval(parse(text=paste(measures[m],"Res_orig_full",sep=""))))[c(1,3,5),1]#
      currEstsA.2phase <- (eval(parse(text=paste(measures[m],"ResA_orig_2phase",sep=""))))[c(1,3,5),]#
      currEstsB.2phase <- (eval(parse(text=paste(measures[m],"ResB_orig_2phase",sep=""))))[c(1,3,5),]#
#
      if(measures[m]=="roc" | measures[m]=="auc" | measures[m]=="hrc" | measures[m]=="b") {#
   	     currEsts.full <- currEsts.full[2] - currEsts.full[1]#
         currEstsA.2phase <- currEstsA.2phase[2,] - currEstsA.2phase[1,]#
         currEstsB.2phase <- currEstsB.2phase[2,] - currEstsB.2phase[1,]#
#
         currBstrap1A.2phase <- currBstrap1B.2phase <- eval(parse(text=paste(measures[m],"X.star2phase",sep="")))#
         currBstrap2A.2phase <- eval(parse(text=paste(measures[m],"XY.star2phase.A",sep="")))#
         currBstrap3A.2phase <- currBstrap2A.2phase - currBstrap1A.2phase#
         currBstrap2B.2phase <- eval(parse(text=paste(measures[m],"XY.star2phase.B",sep="")))#
         currBstrap3B.2phase <- currBstrap2B.2phase - currBstrap1B.2phase#
      }#
      else if(measures[m]=="rocinv" | measures[m]=="hrn") {#
   	     currEsts.full <- currEsts.full[1] - currEsts.full[2]#
         currEstsA.2phase <- currEstsA.2phase[1,] - currEstsA.2phase[2,]#
         currEstsB.2phase <- currEstsB.2phase[1,] - currEstsB.2phase[2,]#
#
         currBstrap1A.2phase <- currBstrap1B.2phase <- eval(parse(text=paste(measures[m],"X.star2phase",sep="")))#
         currBstrap2A.2phase <- eval(parse(text=paste(measures[m],"XY.star2phase.A",sep="")))#
         currBstrap3A.2phase <- currBstrap2A.2phase - currBstrap1A.2phase#
         currBstrap2B.2phase <- eval(parse(text=paste(measures[m],"XY.star2phase.B",sep="")))#
         currBstrap3B.2phase <- currBstrap2B.2phase - currBstrap1B.2phase#
      }      #
      else if(measures[m]=="nri" | measures[m]=="tg" | measures[m]=="idi") {#
         currEsts.full <- currEsts.full[2] + currEsts.full[1]#
         currEstsA.2phase <- currEstsA.2phase[2,] + currEstsA.2phase[1,]#
         currEstsB.2phase <- currEstsB.2phase[2,] + currEstsB.2phase[1,]#
#
         currBstrap1A.2phase <- eval(parse(text=paste(measures[m],"Event.star2phase.A",sep="")))#
         currBstrap2A.2phase <- eval(parse(text=paste(measures[m],"Nonevent.star2phase.A",sep="")))#
         currBstrap3A.2phase <- currBstrap2A.2phase + currBstrap1A.2phase#
         currBstrap1B.2phase <- eval(parse(text=paste(measures[m],"Event.star2phase.B",sep="")))#
         currBstrap2B.2phase <- eval(parse(text=paste(measures[m],"Nonevent.star2phase.B",sep="")))#
         currBstrap3B.2phase <- currBstrap2B.2phase + currBstrap1B.2phase#
      }#
      sdA <- data.frame(t(as.matrix( apply(currBstrap3A.2phase, 2, sd, na.rm=T), nrow=1)))#
      sdB <- data.frame(t(as.matrix( apply(currBstrap3B.2phase, 2, sd, na.rm=T), nrow=1)))      #
      ciA <- sapply(seq(ncol(currBstrap3A.2phase)), function(x){#
         paste( "(", round((currEstsA.2phase[x]) - 1.96*(sdA[x]),3), ", ", round((currEstsA.2phase[x]) + 1.96*(sdA[x]),3), ")", sep="") })#
      ciA <- data.frame(t(as.matrix(ciA, nrow=1)))#
      ciB <- sapply(seq(ncol(currBstrap3B.2phase)), function(x){#
         paste( "(", round((currEstsB.2phase[x]) - 1.96*(sdB[x]),3), ", ", round((currEstsB.2phase[x]) + 1.96*(sdB[x]),3), ")", sep="") })#
      ciB <- data.frame(t(as.matrix(ciB, nrow=1)))#
      names(ciA) <- names(ciB) <- names(currEstsA.2phase)#
#
      if(estProc[e]=="NP") {#
         if(cc==1) {#
            currRow <- c( round(currEsts.full,3),#
               round(currEstsA.2phase$unmatch_non,3), round(sdA$unmatch_non,3), as.character(ciA$unmatch_non),#
               round(currEstsB.2phase$unmatch_non,3), round(sdB$unmatch_non,3), as.character(ciB$unmatch_non) )#
         }#
         if(cc==2) {#
            currRow <- c( round(currEsts.full,3),#
               round(currEstsA.2phase$freq_non,3), round(sdA$freq_non,3), as.character(ciA$freq_non),#
               round(currEstsB.2phase$freq_non,3), round(sdB$freq_non,3), as.character(ciB$freq_non) )#
         }#
      }#
      else if(estProc[e]=="SP") {#
         if(cc==1) {#
            currRow <- c( round(currEsts.full,3),#
               round(currEstsA.2phase$unmatch_semi,3), round(sdA$unmatch_semi,3), as.character(ciA$unmatch_semi),#
               round(currEstsB.2phase$unmatch_semi,3), round(sdB$unmatch_semi,3), as.character(ciB$unmatch_semi) )#
         }#
         if(cc==2) {#
            currRow <- c( round(currEsts.full,3),#
               round(currEstsA.2phase$freq_semi,3), round(sdA$freq_semi,3), as.character(ciA$freq_semi),#
               round(currEstsB.2phase$freq_semi,3), round(sdB$freq_semi,3), as.character(ciB$freq_semi) )#
         }#
      }      #
      results <- rbind(results, currRow)#
   }#
   rownames(results) <- seq(1:nrow(results))#
   print(xtable(results, digits=rep(0,1+ncol(results))), include.rownames=F)#
}#
}
print(estProc[e])
ls()
n <- 1000#
nSimul <- 200
n <- 100
M <- rnorm(n)
T <- exp(0.5 + 0.8*M)#
logTime <- log(T)
T
logTime <- log(T)
logTime
mu <- mean( logTime )#
sigma <- sqrt( var( logTime ) )
mu
sigma
delta <- sigma * c(1:20)/10
delta
sigma
mu <- mean( logTime )#
sigma <- sqrt( var( logTime ) )#
delta <- sigma * c(1:20)/10#
TheOffset <- NULL#
cTime <- matrix( NA, nrow=n, ncol=length(delta) )#
pVec <- rep( NA, length(delta) )#
eee <- rnorm( n )#
for( k in 1:length(delta) ){#
  cTime[,k] <- mu + delta[k] + sigma * eee#
  pVec[k] <- mean( cTime[,k] < logTime )#
  if( pVec[k] >= 0.20 ){#
      delta.use <- delta[k]#
      index.use <- k #
  }#
}
print( pVec )#
print( delta.use )#
print( index.use )
ccc <- cTime[,index.use]
ccc
TheStatus <- as.integer( ccc > logTime )
mean(TheStatus)
print( table( TheStatus ) )#
TheTime <- logTime#
TheTime[ TheStatus==0 ] <- ccc[ TheStatus==0 ]
TheTime
TheTime <- TheTime + 10
TheTime
TheTime <- logTime#
TheTime[ TheStatus==0 ] <- ccc[ TheStatus==0 ]
exp(TheTime)
TheTime
range(TheTime)
TheStatus <- as.integer( ccc > logTime )#
print( table( TheStatus ) )#
TheTime <- logTime#
TheTime[ TheStatus==0 ] <- ccc[ TheStatus==0 ]#
TheTime <- exp(TheTime)
range(TheTime)
times <- c(2,3,4,5,6)
i
i <- 1
times <- c(2,3,4,5,6)#
results <- matrix(nrow=times, ncol=3)#
colnames(results) <- c("HR_lm","AUC_cd","AUC_id","HR_ll")
colnames(results) <- c("HR_lm","AUC_cd","AUC_id","HR_ll")#
rownames(results) <- times
times <- c(2,3,4,5,6)#
results <- matrix(nrow=length(times), ncol=4)#
colnames(results) <- c("HR_lm","AUC_cd","AUC_id","HR_ll")#
rownames(results) <- times
i
fit <- coxph( as.formula( Surv(TheTime, TheStatus) ~ TheMarker ), data=sim.data )
library(survival)
i
Estimate beta and AUC#
library(survival)#
library(risksetROC)#
library(survivalROC)
times <- c(2,3,4,5,6)#
results <- matrix(nrow=length(times), ncol=4)#
colnames(results) <- c("HR_lm","AUC_cd","AUC_id","HR_ll")#
rownames(results) <- times#
localLin <- list(length=length(varsConts_singleVars))
fit <- coxph( as.formula( Surv(TheTime, TheStatus) ~ TheMarker ), data=sim.data )
summary(fit)$coefficients
ccc <- cTime[,index.use]#
##
TheStatus <- as.integer( ccc > logTime )#
print( table( TheStatus ) )#
TheTime <- logTime#
TheTime[ TheStatus==0 ] <- ccc[ TheStatus==0 ]#
TheTime <- exp(TheTime)#
#TheTime <- TheTime + 10#
##
sim.data <- data.frame( TheTime = TheTime, TheStatus = TheStatus,#
                        TheMarker = M )
fit <- coxph( as.formula( Surv(TheTime, TheStatus) ~ TheMarker ), data=sim.data )
fit
summary(fit)$coefficients
round(summary(fit)$coefficients[2],2)
summary(fit)$coefficients[2]
localLin <- llCoxReg(Stime=sim.data$TheTime, entry = NULL, status=sim.data$TheStatus,#
         marker=sim.data$TheMarker, span = 0.35, p = 1, window = "asymmetric")
warnings()
localLin
times <- c(0,2,3,4,5,6)#
results <- matrix(nrow=length(times), ncol=4)#
colnames(results) <- c("HR_lm","AUC_cd","AUC_id","HR_ll")#
rownames(results) <- times#
#
for(i in 1:length(times)) {#
	  currLandmark <- subset(sim.data, TheTime >= times[i])#
      fit <- coxph( as.formula( Surv(TheTime, TheStatus) ~ TheMarker ), data=currLandmark )#
      results[i,1] <- round(summary(fit)$coefficients[2],2)#
#
      out1 <- survivalROC( sim.data$TheTime, sim.data$TheStatus, sim.data$TheMarker,#
         predict.time = times[j], method = "NNE", span = 0.25 * nobs^(-0.2)  )#
      results[i,2] <- out1$AUC                     #
      #localLin <- llCoxReg(Stime=sim.data$TheTime, entry = NULL, status=sim.data$TheStatus,#
      #   marker=sim.data$TheMarker, span = 0.35, p = 1, window = "asymmetric")#
}
Estimate beta and AUC#
times <- c(0,2,3,4,5,6)#
results <- matrix(nrow=length(times), ncol=4)#
colnames(results) <- c("HR_lm","AUC_cd","AUC_id","HR_ll")#
rownames(results) <- times#
#
for(i in 1:length(times)) {#
	  currLandmark <- subset(sim.data, TheTime >= times[i])#
      fit <- coxph( as.formula( Surv(TheTime, TheStatus) ~ TheMarker ), data=currLandmark )#
      results[i,1] <- round(summary(fit)$coefficients[2],2)#
#
      out1 <- survivalROC( sim.data$TheTime, sim.data$TheStatus, sim.data$TheMarker,#
         predict.time = times[i], method = "NNE", span = 0.25 * nobs^(-0.2)  )#
      results[i,2] <- out1$AUC                     #
      #localLin <- llCoxReg(Stime=sim.data$TheTime, entry = NULL, status=sim.data$TheStatus,#
      #   marker=sim.data$TheMarker, span = 0.35, p = 1, window = "asymmetric")#
}
nobs
for(i in 1:length(times)) {#
	  currLandmark <- subset(sim.data, TheTime >= times[i])#
      fit <- coxph( as.formula( Surv(TheTime, TheStatus) ~ TheMarker ), data=currLandmark )#
      results[i,1] <- round(summary(fit)$coefficients[2],2)#
#
      out1 <- survivalROC( sim.data$TheTime, sim.data$TheStatus, sim.data$TheMarker,#
         predict.time = times[i], method = "NNE", span = 0.25 * n^(-0.2)  )#
      results[i,2] <- out1$AUC                     #
      #localLin <- llCoxReg(Stime=sim.data$TheTime, entry = NULL, status=sim.data$TheStatus,#
      #   marker=sim.data$TheMarker, span = 0.35, p = 1, window = "asymmetric")#
}
n <- 1000#
nSimul <- 200
for(i in 1:length(times)) {#
	  currLandmark <- subset(sim.data, TheTime >= times[i])#
      fit <- coxph( as.formula( Surv(TheTime, TheStatus) ~ TheMarker ), data=currLandmark )#
      results[i,1] <- round(summary(fit)$coefficients[2],2)#
#
      out1 <- survivalROC( sim.data$TheTime, sim.data$TheStatus, sim.data$TheMarker,#
         predict.time = times[i], method = "NNE", span = 0.25 * n^(-0.2)  )#
      results[i,2] <- out1$AUC                     #
      #localLin <- llCoxReg(Stime=sim.data$TheTime, entry = NULL, status=sim.data$TheStatus,#
      #   marker=sim.data$TheMarker, span = 0.35, p = 1, window = "asymmetric")#
}
times <- c(2,3,4,5,6)#
results <- matrix(nrow=length(times), ncol=4)#
colnames(results) <- c("HR_lm","AUC_cd","AUC_id","HR_ll")#
rownames(results) <- times
for(i in 1:length(times)) {#
	  currLandmark <- subset(sim.data, TheTime >= times[i])#
      fit <- coxph( as.formula( Surv(TheTime, TheStatus) ~ TheMarker ), data=currLandmark )#
      results[i,1] <- round(summary(fit)$coefficients[2],2)#
#
      out1 <- survivalROC( sim.data$TheTime, sim.data$TheStatus, sim.data$TheMarker,#
         predict.time = times[i], method = "NNE", span = 0.25 * n^(-0.2)  )#
      results[i,2] <- out1$AUC                     #
      #localLin <- llCoxReg(Stime=sim.data$TheTime, entry = NULL, status=sim.data$TheStatus,#
      #   marker=sim.data$TheMarker, span = 0.35, p = 1, window = "asymmetric")#
}
Setting 2 - Normal distribution for marker#
M <- rnorm(n)#
T <- exp(0.5 + 0.8*M)#
logTime <- log(T)#
#C <- rnorm(n, mean=n*.3)
Some censoring...#
mu <- mean( logTime )#
sigma <- sqrt( var( logTime ) )#
delta <- sigma * c(1:20)/10#
TheOffset <- NULL#
cTime <- matrix( NA, nrow=n, ncol=length(delta) )#
pVec <- rep( NA, length(delta) )#
eee <- rnorm( n )#
for( k in 1:length(delta) ){#
  cTime[,k] <- mu + delta[k] + sigma * eee#
  pVec[k] <- mean( cTime[,k] < logTime )#
  if( pVec[k] >= 0.20 ){#
      delta.use <- delta[k]#
      index.use <- k #
  }#
}#
print( pVec )#
print( delta.use )#
print( index.use )#
##
##### Final data...#
##
ccc <- cTime[,index.use]#
##
TheStatus <- as.integer( ccc > logTime )#
print( table( TheStatus ) )#
TheTime <- logTime#
TheTime[ TheStatus==0 ] <- ccc[ TheStatus==0 ]#
TheTime <- exp(TheTime)#
#TheTime <- TheTime + 10#
##
sim.data <- data.frame( TheTime = TheTime, TheStatus = TheStatus,#
                        TheMarker = M )
Estimate beta and AUC#
times <- c(2,3,4,5,6)#
results <- matrix(nrow=length(times), ncol=4)#
colnames(results) <- c("HR_lm","AUC_cd","AUC_id","HR_ll")#
rownames(results) <- times#
#
for(i in 1:length(times)) {#
	  currLandmark <- subset(sim.data, TheTime >= times[i])#
      fit <- coxph( as.formula( Surv(TheTime, TheStatus) ~ TheMarker ), data=currLandmark )#
      results[i,1] <- round(summary(fit)$coefficients[2],2)#
#
      out1 <- survivalROC( sim.data$TheTime, sim.data$TheStatus, sim.data$TheMarker,#
         predict.time = times[i], method = "NNE", span = 0.25 * n^(-0.2)  )#
      results[i,2] <- out1$AUC                     #
      #localLin <- llCoxReg(Stime=sim.data$TheTime, entry = NULL, status=sim.data$TheStatus,#
      #   marker=sim.data$TheMarker, span = 0.35, p = 1, window = "asymmetric")#
}
results
TheTime <- TheTime + 10#
##
sim.data <- data.frame( TheTime = TheTime, TheStatus = TheStatus,#
                        TheMarker = M )
times <- c(2,3,4,5,6)#
results <- matrix(nrow=length(times), ncol=4)#
colnames(results) <- c("HR_lm","AUC_cd","AUC_id","HR_ll")#
rownames(results) <- times#
#
for(i in 1:length(times)) {#
	  currLandmark <- subset(sim.data, TheTime >= times[i])#
      fit <- coxph( as.formula( Surv(TheTime, TheStatus) ~ TheMarker ), data=currLandmark )#
      results[i,1] <- round(summary(fit)$coefficients[2],2)#
#
      out1 <- survivalROC( sim.data$TheTime, sim.data$TheStatus, sim.data$TheMarker,#
         predict.time = times[i], method = "NNE", span = 0.25 * n^(-0.2)  )#
      results[i,2] <- out1$AUC                     #
}
sim.data$TheTime
Setting 2 - Normal distribution for marker#
M <- rnorm(n)#
T <- exp(1 + 1.5*M)#
logTime <- log(T)#
#C <- rnorm(n, mean=n*.3)
Some censoring...#
mu <- mean( logTime )#
sigma <- sqrt( var( logTime ) )#
delta <- sigma * c(1:20)/10#
TheOffset <- NULL#
cTime <- matrix( NA, nrow=n, ncol=length(delta) )#
pVec <- rep( NA, length(delta) )#
eee <- rnorm( n )#
for( k in 1:length(delta) ){#
  cTime[,k] <- mu + delta[k] + sigma * eee#
  pVec[k] <- mean( cTime[,k] < logTime )#
  if( pVec[k] >= 0.20 ){#
      delta.use <- delta[k]#
      index.use <- k #
  }#
}#
print( pVec )#
print( delta.use )#
print( index.use )
ccc <- cTime[,index.use]#
##
TheStatus <- as.integer( ccc > logTime )#
print( table( TheStatus ) )#
TheTime <- logTime#
TheTime[ TheStatus==0 ] <- ccc[ TheStatus==0 ]#
TheTime <- exp(TheTime)#
#TheTime <- TheTime + 10#
##
sim.data <- data.frame( TheTime = TheTime, TheStatus = TheStatus,#
                        TheMarker = M )
times <- c(2,3,4,5,6)#
results <- matrix(nrow=length(times), ncol=4)#
colnames(results) <- c("HR_lm","AUC_cd","AUC_id","HR_ll")#
rownames(results) <- times
for(i in 1:length(times)) {#
	  currLandmark <- subset(sim.data, TheTime >= times[i])#
      fit <- coxph( as.formula( Surv(TheTime, TheStatus) ~ TheMarker ), data=currLandmark )#
      results[i,1] <- round(summary(fit)$coefficients[2],2)#
#
      out1 <- survivalROC( sim.data$TheTime, sim.data$TheStatus, sim.data$TheMarker,#
         predict.time = times[i], method = "NNE", span = 0.25 * n^(-0.2)  )#
      results[i,2] <- out1$AUC                     #
}
currLambda <-  0.2#
mmm <- MeanRank( sim.data$TheTime, sim.data$TheStatus, sim.data$TheMarker )#
nnn <- nne( x= mmm$time, y= mmm$mean.rank, lambda=currLambda )  #Fixed bandwidth#
results[, 3] <- #
      c(interpolate( x = nnn$x, y=nnn$nne, target=2*units ),#
      interpolate( x = nnn$x, y=nnn$nne, target=3*units ), interpolate( x = nnn$x, y=nnn$nne, target=4*units ),#
      interpolate( x = nnn$x, y=nnn$nne, target=5*units ), interpolate( x = nnn$x, y=nnn$nne, target=6*units ) )
results
n
source("/Users/aasthaa/Dropbox/Postdoc/DynamicPlacementValue/MeanRank.q")#
source("/Users/aasthaa/Dropbox/Postdoc/DynamicPlacementValue/NNE-estimate.q")#
source("/Users/aasthaa/Dropbox/Postdoc/DynamicPlacementValue/NNE-CrossValidation.q")#
source("/Users/aasthaa/Dropbox/Postdoc/DynamicPlacementValue/interpolate.q")
currLambda <-  0.2#
mmm <- MeanRank( sim.data$TheTime, sim.data$TheStatus, sim.data$TheMarker )#
nnn <- nne( x= mmm$time, y= mmm$mean.rank, lambda=currLambda )  #Fixed bandwidth#
results[, 3] <- #
      c(interpolate( x = nnn$x, y=nnn$nne, target=2*units ),#
      interpolate( x = nnn$x, y=nnn$nne, target=3*units ), interpolate( x = nnn$x, y=nnn$nne, target=4*units ),#
      interpolate( x = nnn$x, y=nnn$nne, target=5*units ), interpolate( x = nnn$x, y=nnn$nne, target=6*units ) )#
localLin <- llCoxReg(Stime=sim.data$TheTime, entry = NULL, status=sim.data$TheStatus,#
   marker=sim.data$TheMarker, span = 0.35, p = 1, window = "asymmetric")#
nnn_localLin <- nne( x= localLin$time, y= localLin$beta[,2], lambda=currLambda )  #Fixed bandwidth#
results[, 4] <- #
      c(interpolate( x = nnn_localLin$x, y= nnn_localLin$nne, target=2*units ),#
      interpolate( x = nnn_localLin$x, y= nnn_localLin$nne, target=3*units ), interpolate( x = nnn_localLin$x, y= nnn_localLin$nne, target=4*units ),#
      interpolate( x = nnn_localLin$x, y= nnn_localLin$nne, target=5*units ), interpolate( x = nnn_localLin$x, y= nnn_localLin$nne, target=6*units ) )
currLambda <-  0.2#
mmm <- MeanRank( sim.data$TheTime, sim.data$TheStatus, sim.data$TheMarker )#
nnn <- nne( x= mmm$time, y= mmm$mean.rank, lambda=currLambda )  #Fixed bandwidth#
results[, 3] <- #
      c(interpolate( x = nnn$x, y=nnn$nne, target=times[1] ),#
      interpolate( x = nnn$x, y=nnn$nne, target=times[2] ), interpolate( x = nnn$x, y=nnn$nne, target=times[3] ),#
      interpolate( x = nnn$x, y=nnn$nne, target=times[4] ), interpolate( x = nnn$x, y=nnn$nne, target=times[5] ) )
localLin <- llCoxReg(Stime=sim.data$TheTime, entry = NULL, status=sim.data$TheStatus,#
   marker=sim.data$TheMarker, span = 0.35, p = 1, window = "asymmetric")#
nnn_localLin <- nne( x= localLin$time, y= localLin$beta[,2], lambda=currLambda )  #Fixed bandwidth#
results[, 4] <- #
      c(interpolate( x = nnn_localLin$x, y= nnn_localLin$nne, target=times[1] ),#
      interpolate( x = nnn_localLin$x, y= nnn_localLin$nne, target=times[2] ),#
      interpolate( x = nnn_localLin$x, y= nnn_localLin$nne, target=times[3] ),#
      interpolate( x = nnn_localLin$x, y= nnn_localLin$nne, target=times[4] ),#
      interpolate( x = nnn_localLin$x, y= nnn_localLin$nne, target=times[5] ) )
warnings()
ls()
library(mvtnorm)#
# bootstrap CI approach #3#
# each subject is assigned with random/different residuals in different BS resamples#
# No original Y used#
# cohort size is 5000, and case-control sample size is 250+500=750#
######################### codes for calculating ROC, ROCINV and AUC and they were obtained from Aasthaa in 2009#
## note that we have to specify d in form of 0,0,...,0,1,1,...,1 to make the functions work properly#
# Calculate percentile values using empirical method#
pcval <- function(d, y, tiecorr) {#
	n_db <- length(d[d==0])#
	Y_db <- sort(y[1:n_db])#
	y_j <- sort(y[(n_db+1):length(y)])#
	# Calculate P(Y_db <= y_j)#
	F_le <- ecdf(Y_db)#
	# Calculate P(Y_db < y_j)#
	y_j_neg <- -(y_j)#
	Y_db_neg <- -(Y_db)#
	F_l_neg <- ecdf(Y_db_neg)#
	F_l <- rep(1, length(y_j)) - F_l_neg(y_j_neg)#
	if(!tiecorr)#
		pcv_j <- F_l		# P(Y_db < y_j)#
	else #
		pcv_j <- F_l + 0.5*(F_le(y_j) - F_l)	# P(Y_db < y_j) + 0.5*P(Y_db = y_j)#
	return(pcv_j)#
}#
# Get ROC value at given t#
roct <- function(d, y, tiecorr=FALSE, t) {#
	pcvals <- pcval(d, y, tiecorr)#
	F_pl <- ecdf(1-pcvals)#
	return(F_pl(t))#
}#
# Get inverse of ROC function, at a given TPF=v#
rocinv <- function(d, y, tiecorr=FALSE, v) {#
	d_new <- 1-d#
	y_new <- -y#
	dataset_new <- as.data.frame(cbind(y_new, d_new))#
	dataset_new <- dataset_new[order(dataset_new$d_new),]#
	pcvals <- pcval(dataset_new$d_new, dataset_new$y_new, tiecorr)#
	FPF_new <- 1-pcvals#
	F_pl_new <- ecdf(FPF_new)#
	TPF_new <- F_pl_new(FPF_new)#
	return(1 - F_pl_new(1-v))#
}#
# Get AUC for ROC curve#
calcAuc <- function(d, y, tiecorr=FALSE) {#
	return(mean(pcval(d, y, tiecorr)))#
}#
################################################################
############################# codes for one bootstrap step###################
# the function below returns a matrix of estimates in one BS step.#
# there are 9 rows which represent the 9 summary measures used in the paper, and the order is the same as that in paper.#
# there are 4 columns which are (from left to right) unmatched Madj, unmatched M2-stage, matched Madj and matched M2-stage.#
one.BS <- function(orid, orix, orimv, N, n0, n1, bint0, bx0, sigma0, err0, bint1, bx1, sigma1, err1, #
	bint2, bx2, sigma2, err2, bint3, bx3, sigma3, err3){#
	n <- n0 + n1#
	ta <- NULL	#
	idx <- sort(sample(N, N, replace=T)) # make sure we get d with controls coming first and then cases#
	d <- orid[idx]#
	x <- orix[idx]#
	mv <- orimv[idx]#
	preval <- sum(d)/N#
	rx_true <- fitted(glm(d~x, family=binomial("logit")))#
	predx_true <- predict(glm(d~x, family=binomial("logit")))#
	fx0 <- ecdf(rx_true[d==0])#
	fx1 <- ecdf(rx_true[d==1])#
	idx_un <- c(sample(which(d==0), n0), sample(which(d==1), n1))#
	d_un <- d[idx_un]#
	x_un <- x[idx_un] #
	y_un <- c((bint0+bx0*(x_un[d_un==0])+sigma0*sample(err0, n0, replace=T)), (bint1+bx1*(x_un[d_un==1])+sigma1*sample(err1, n1, replace=T)))#
	rx_true_un <- rx_true[idx_un] #
	# Madj approach#
	rxy_un_M <- plogis(predict(glm(d_un~x_un+y_un, family=binomial("logit"))) + qlogis(preval) - qlogis(n1/n))#
	fxy0 <- ecdf(rxy_un_M[d_un==0])#
	fxy1 <- ecdf(rxy_un_M[d_un==1])#
	dhr1 <- fx1(0.2) - fxy1(0.2)#
	dhr0 <- fxy0(0.2) - fx0(0.2)#
	db <- dhr1 + (1-preval)*0.25*dhr0/preval#
	drocinv <- rocinv(d, rx_true, v=0.8) - rocinv(d_un, rxy_un_M, v=0.8)#
	droct <- roct(d_un, rxy_un_M, t=0.1) - roct(d, rx_true, t=0.1)#
	dauc <- calcAuc(d_un, rxy_un_M) - calcAuc(d, rx_true)#
	dmrd <- mean(rxy_un_M[d_un==1])-mean(rxy_un_M[d_un==0])-mean(rx_true[d==1])+mean(rx_true[d==0])#
	daard <- fxy0(preval)-fxy1(preval)-fx0(preval)+fx1(preval)#
	nri <- 2*(mean(rxy_un_M[d_un==1] > rx_true_un[d_un==1]) - mean(rxy_un_M[d_un==0] > rx_true_un[d_un==0])) #
	ta <- cbind(ta, c(dhr1, dhr0, db, drocinv, droct, dauc, dmrd, daard, nri))#
	# 2-stage approach	#
	rxy_un_2 <- plogis(predict(glm(d_un~x_un+y_un, family=binomial("logit"))) + predx_true[idx_un] - predict(glm(d_un~x_un, family=binomial("logit"))))#
	fxy0 <- ecdf(rxy_un_2[d_un==0])#
	fxy1 <- ecdf(rxy_un_2[d_un==1])#
	dhr1 <- fx1(0.2) - fxy1(0.2)#
	dhr0 <- fxy0(0.2) - fx0(0.2)#
	db <- dhr1 + (1-preval)*0.25*dhr0/preval#
	drocinv <- rocinv(d, rx_true, v=0.8) - rocinv(d_un, rxy_un_2, v=0.8)#
	droct <- roct(d_un, rxy_un_2, t=0.1) - roct(d, rx_true, t=0.1)#
	dauc <- calcAuc(d_un, rxy_un_2) - calcAuc(d, rx_true)#
	dmrd <- mean(rxy_un_2[d_un==1])-mean(rxy_un_2[d_un==0])-mean(rx_true[d==1])+mean(rx_true[d==0])#
	daard <- fxy0(preval)-fxy1(preval)-fx0(preval)+fx1(preval)#
	nri <- 2*(mean(rxy_un_2[d_un==1] > rx_true_un[d_un==1]) - mean(rxy_un_2[d_un==0] > rx_true_un[d_un==0])) #
	ta <- cbind(ta, c(dhr1, dhr0, db, drocinv, droct, dauc, dmrd, daard, nri))#
	# get matched cc samples#
	idx1_m <- idx_un[(n0+1):n] # make sure idx_un gives controls first and then cases #
	idx0_m <- NULL#
	ss <- 2*sum(mv[idx1_m]==1)#
	tmps <- sample(intersect(which(d==0), which(mv==1)), ss)#
	idx0_m <- c(idx0_m, tmps)#
	ss <- 2*sum(mv[idx1_m]==2)#
	tmps <- sample(intersect(which(d==0), which(mv==2)), ss)#
	idx0_m <- c(idx0_m, tmps)#
	ss <- 2*sum(mv[idx1_m]==3)#
	tmps <- sample(intersect(which(d==0), which(mv==3)), ss)#
	idx0_m <- c(idx0_m, tmps)#
	ss <- 2*sum(mv[idx1_m]==4)#
	tmps <- sample(intersect(which(d==0), which(mv==4)), ss)#
	idx0_m <- c(idx0_m, tmps)#
	idx_m <- c(idx0_m, idx1_m)#
	d_m <- c(rep(0, n0), rep(1, n1))#
	x_m <- x[idx_m] #
	y_m <- c((bint2+bx2*(x_m[d_m==0])+sigma2*sample(err2, n0, replace=T)), (bint3+bx3*(x_m[d_m==1])+sigma3*sample(err3, n1, replace=T)))#
	mv_m <- mv[idx_m]#
	rx_true_m <- rx_true[idx_m] #
	# Madj approach#
	rxy_m_M <- plogis(predict(glm(d_m~x_m+y_m, family=binomial("logit"))) + qlogis(preval) - qlogis(n1/n))#
	fxy1 <- ecdf(rxy_m_M[d_m==1])#
	s_case <- rxy_m_M[d_m==1]#
	fs_case <- fxy1(s_case)#
	fs_idx1 <- rank(s_case, ties.method="first")#
	s_case[fs_idx1] <- s_case#
	fs_case[fs_idx1] <- fs_case#
	rs_prob_control <- length(intersect(which(mv==1), which(d==0))) / length(which(d==0))#
	rs_prob_control <- rbind(rs_prob_control, length(intersect(which(mv==2), which(d==0))) / length(which(d==0)))#
	rs_prob_control <- rbind(rs_prob_control, length(intersect(which(mv==3), which(d==0))) / length(which(d==0)))#
	rs_prob_control <- rbind(rs_prob_control, length(intersect(which(mv==4), which(d==0))) / length(which(d==0)))#
	s_control <- rxy_m_M[1:(sum(d[idx_m]==0))]#
	rs_m_control <- mv_m[1:(sum(d[idx_m]==0))]#
	ecdf_control_1 <- ecdf(s_control[which(rs_m_control==1)])#
	ecdf_control_2 <- ecdf(s_control[which(rs_m_control==2)])#
	ecdf_control_3 <- ecdf(s_control[which(rs_m_control==3)])#
	ecdf_control_4 <- ecdf(s_control[which(rs_m_control==4)])#
	fs_control <- cbind(ecdf_control_1(s_control), ecdf_control_2(s_control), ecdf_control_3(s_control), ecdf_control_4(s_control)) %*% rs_prob_control  #
	fs_idx <- rank(s_control, ties.method="first")#
	s_control[fs_idx] <- s_control#
	fs_control[fs_idx] <- fs_control#
	fxy0 <- function(r){#
		return(cbind(ecdf_control_1(r), ecdf_control_2(r), ecdf_control_3(r), ecdf_control_4(r)) %*% rs_prob_control)#
	}#
	roct_dlr <- function(t){#
		idx <- min(which(fs_control >= (1-t)))#
		return(1-fxy1(s_control[idx]))#
	}#
	roct_dlr2 <- function(t){#
		idx <- min(which(fs_case >= (1-t)))#
		return(1-fxy0(s_case[idx]))#
	}#
	dhr1 <- fx1(0.2) - fxy1(0.2)#
	dhr0 <- fxy0(0.2) - fx0(0.2)#
	db <- dhr1 + (1-preval)*0.25*dhr0/preval#
	drocinv <- rocinv(d, rx_true, v=0.8) - roct_dlr2(0.8)#
	droct <- roct_dlr(0.1) - roct(d, rx_true, t=0.1)#
	dauc <- sum(fxy0(s_case))/n1 - calcAuc(d, rx_true)#
	mrd1 <- cbind(mean(s_control[which(rs_m_control==1)]), mean(s_control[which(rs_m_control==2)]), mean(s_control[which(rs_m_control==3)]), mean(s_control[which(rs_m_control==4)]))%*% rs_prob_control #
	dmrd <- mean(rxy_m_M[d_m==1])- mrd1 - mean(rx_true[d==1]) + mean(rx_true[d==0])#
	daard <- fxy0(preval)-fxy1(preval)-fx0(preval)+fx1(preval)#
	noneventnri <- mean(rxy_m_M[intersect(which(d_m==0), which(mv_m==1))] > rx_true_m[intersect(which(d_m==0), which(mv_m==1))])#
	noneventnri <- cbind(noneventnri, mean(rxy_m_M[intersect(which(d_m==0), which(mv_m==2))] > rx_true_m[intersect(which(d_m==0), which(mv_m==2))]))#
	noneventnri <- cbind(noneventnri, mean(rxy_m_M[intersect(which(d_m==0), which(mv_m==3))] > rx_true_m[intersect(which(d_m==0), which(mv_m==3))]))#
	noneventnri <- cbind(noneventnri, mean(rxy_m_M[intersect(which(d_m==0), which(mv_m==4))] > rx_true_m[intersect(which(d_m==0), which(mv_m==4))]))#
	nri <- 2*(mean(rxy_m_M[d_m==1] > rx_true_m[d_m==1]) - (noneventnri%*%rs_prob_control)) #
	ta <- cbind(ta, c(dhr1, dhr0, db, drocinv, droct, dauc, dmrd, daard, nri))#
	# 2-stage approach#
	rxy_m_2 <- plogis(predict(glm(d_m~x_m+y_m, family=binomial("logit"))) + predx_true[idx_m] - predict(glm(d_m~x_m, family=binomial("logit"))))#
	fxy1 <- ecdf(rxy_m_2[d_m==1])#
	s_case <- rxy_m_2[d_m==1]#
	fs_case <- fxy1(s_case)#
	fs_idx1 <- rank(s_case, ties.method="first")#
	s_case[fs_idx1] <- s_case#
	fs_case[fs_idx1] <- fs_case#
	s_control <- rxy_m_2[1:(sum(d[idx_m]==0))]#
	rs_m_control <- mv_m[1:(sum(d[idx_m]==0))]#
	ecdf_control_1 <- ecdf(s_control[which(rs_m_control==1)])#
	ecdf_control_2 <- ecdf(s_control[which(rs_m_control==2)])#
	ecdf_control_3 <- ecdf(s_control[which(rs_m_control==3)])#
	ecdf_control_4 <- ecdf(s_control[which(rs_m_control==4)])#
	fs_control <- cbind(ecdf_control_1(s_control), ecdf_control_2(s_control), ecdf_control_3(s_control), ecdf_control_4(s_control)) %*% rs_prob_control  #
	fs_idx <- rank(s_control, ties.method="first")#
	s_control[fs_idx] <- s_control#
	fs_control[fs_idx] <- fs_control#
	fxy0 <- function(r){#
		return(cbind(ecdf_control_1(r), ecdf_control_2(r), ecdf_control_3(r), ecdf_control_4(r)) %*% rs_prob_control)#
	}#
	roct_dlr <- function(t){#
		idx <- min(which(fs_control >= (1-t)))#
		return(1-fxy1(s_control[idx]))#
	}#
	roct_dlr2 <- function(t){#
		idx <- min(which(fs_case >= (1-t)))#
		return(1-fxy0(s_case[idx]))#
	}#
	dhr1 <- fx1(0.2) - fxy1(0.2)#
	dhr0 <- fxy0(0.2) - fx0(0.2)#
	db <- dhr1 + (1-preval)*0.25*dhr0/preval#
	drocinv <- rocinv(d, rx_true, v=0.8) - roct_dlr2(0.8)#
	droct <- roct_dlr(0.1) - roct(d, rx_true, t=0.1)#
	dauc <- sum(fxy0(s_case))/n1 - calcAuc(d, rx_true)#
	mrd1 <- cbind(mean(s_control[which(rs_m_control==1)]), mean(s_control[which(rs_m_control==2)]), mean(s_control[which(rs_m_control==3)]), mean(s_control[which(rs_m_control==4)]))%*% rs_prob_control #
	dmrd <- mean(rxy_m_2[d_m==1])- mrd1 - mean(rx_true[d==1]) + mean(rx_true[d==0])#
	daard <- fxy0(preval)-fxy1(preval)-fx0(preval)+fx1(preval)#
	noneventnri <- mean(rxy_m_2[intersect(which(d_m==0), which(mv_m==1))] > rx_true_m[intersect(which(d_m==0), which(mv_m==1))])#
	noneventnri <- cbind(noneventnri, mean(rxy_m_2[intersect(which(d_m==0), which(mv_m==2))] > rx_true_m[intersect(which(d_m==0), which(mv_m==2))]))#
	noneventnri <- cbind(noneventnri, mean(rxy_m_2[intersect(which(d_m==0), which(mv_m==3))] > rx_true_m[intersect(which(d_m==0), which(mv_m==3))]))#
	noneventnri <- cbind(noneventnri, mean(rxy_m_2[intersect(which(d_m==0), which(mv_m==4))] > rx_true_m[intersect(which(d_m==0), which(mv_m==4))]))#
	nri <- 2*(mean(rxy_m_2[d_m==1] > rx_true_m[d_m==1]) - (noneventnri%*%rs_prob_control)) #
	ta <- cbind(ta, c(dhr1, dhr0, db, drocinv, droct, dauc, dmrd, daard, nri))#
	return(ta)#
}#
################################ codes for one simulation ################
# the function below returns a matrix recording coverage of all BS CIs, including both normality-based and quantile-based BS CIs.#
# there are 9 rows which represent the 9 summary measures used in the paper, and the order is the same as that in paper.#
# there are 8 columns, and the fisrt 4 colums are for normality-based BS CIs in the order of unmatched Madj, unmatched M2-stage, matched Madj and matched M2-stage..#
do.one <- function(trueval){#
## generate cohort#
N <- 5000#
preval <- 0.1#
N1 <- N*preval#
N0 <- N - N1#
corr <- 0.5#
d <- c(rep(0, N0), rep(1, N1))#
xy <- rbind(rmvnorm(N0, c(0,0), matrix(c(1,corr,corr,1),2,2)), rmvnorm(N1, c(0.742,0.742), matrix(c(1,corr,corr,1),2,2)))#
x <- xy[,1]#
y <- xy[,2]#
xq <- quantile(x[d==0], c(0.25, 0.5, 0.75))#
mv <- rep(2, N)#
mv[x<xq[1]] <- 1#
mv[intersect(which(x<xq[3]), which(x>=xq[2]))] <- 3#
mv[x>=xq[3]] <- 4#
ta <- NULL#
# get estimates in the cohort#
rx_true <- fitted(glm(d~x, family=binomial("logit")))#
predx_true <- predict(glm(d~x, family=binomial("logit")))#
rxy_true <- fitted(glm(d~x+y, family=binomial("logit")))#
fx0 <- ecdf(rx_true[d==0])#
fx1 <- ecdf(rx_true[d==1])#
fxy0 <- ecdf(rxy_true[d==0])#
fxy1 <- ecdf(rxy_true[d==1])#
dhr1 <- fx1(0.2) - fxy1(0.2)#
dhr0 <- fxy0(0.2) - fx0(0.2)#
db <- dhr1 + (1-preval)*0.25*dhr0/preval#
drocinv <- rocinv(d, rx_true, v=0.8) - rocinv(d, rxy_true, v=0.8)#
droct <- roct(d, rxy_true, t=0.1) - roct(d, rx_true, t=0.1)#
dauc <- calcAuc(d, rxy_true) - calcAuc(d, rx_true)#
dmrd <- mean(rxy_true[d==1])-mean(rxy_true[d==0])-mean(rx_true[d==1])+mean(rx_true[d==0])#
daard <- fxy0(preval)-fxy1(preval)-fx0(preval)+fx1(preval)#
nri <- 2*(mean(rxy_true[d==1] > rx_true[d==1]) - mean(rxy_true[d==0] > rx_true[d==0])) #
###############################
## move on to cc samples#
n0 <- 500#
n1 <- 250#
n <- n0 + n1#
##############################
# get unmatched cc samples#
idx_un <- c(sample(1:N0, n0), sample(((N0+1):N), n1))#
d_un <- c(rep(0, n0), rep(1, n1))#
x_un <- x[idx_un] #
y_un <- y[idx_un] #
rx_true_un <- rx_true[idx_un] #
spmod_un0 <- lm(y_un[d_un==0] ~ x_un[d_un==0])#
bint0 <- (summary(spmod_un0)$coefficients)[1]#
bx0 <- (summary(spmod_un0)$coefficients)[2]#
sigma0 <- summary(spmod_un0)$sigma#
err0 <- summary(spmod_un0)$resid#
spmod_un1 <- lm(y_un[d_un==1] ~ x_un[d_un==1])#
bint1 <- (summary(spmod_un1)$coefficients)[1]#
bx1 <- (summary(spmod_un1)$coefficients)[2]#
sigma1 <- summary(spmod_un1)$sigma#
err1 <- summary(spmod_un1)$resid#
# Madj approach#
rxy_un_M <- plogis(predict(glm(d_un~x_un+y_un, family=binomial("logit"))) + qlogis(preval) - qlogis(n1/n))#
fxy0 <- ecdf(rxy_un_M[d_un==0])#
fxy1 <- ecdf(rxy_un_M[d_un==1])#
dhr1 <- fx1(0.2) - fxy1(0.2)#
dhr0 <- fxy0(0.2) - fx0(0.2)#
db <- dhr1 + (1-preval)*0.25*dhr0/preval#
drocinv <- rocinv(d, rx_true, v=0.8) - rocinv(d_un, rxy_un_M, v=0.8)#
droct <- roct(d_un, rxy_un_M, t=0.1) - roct(d, rx_true, t=0.1)#
dauc <- calcAuc(d_un, rxy_un_M) - calcAuc(d, rx_true)#
dmrd <- mean(rxy_un_M[d_un==1])-mean(rxy_un_M[d_un==0])-mean(rx_true[d==1])+mean(rx_true[d==0])#
daard <- fxy0(preval)-fxy1(preval)-fx0(preval)+fx1(preval)#
nri <- 2*(mean(rxy_un_M[d_un==1] > rx_true_un[d_un==1]) - mean(rxy_un_M[d_un==0] > rx_true_un[d_un==0])) #
ta <- cbind(ta, c(dhr1, dhr0, db, drocinv, droct, dauc, dmrd, daard, nri))#
# 2-stage approach#
rxy_un_2 <- plogis(predict(glm(d_un~x_un+y_un, family=binomial("logit"))) + predx_true[idx_un] - predict(glm(d_un~x_un, family=binomial("logit"))))#
fxy0 <- ecdf(rxy_un_2[d_un==0])#
fxy1 <- ecdf(rxy_un_2[d_un==1])#
dhr1 <- fx1(0.2) - fxy1(0.2)#
dhr0 <- fxy0(0.2) - fx0(0.2)#
db <- dhr1 + (1-preval)*0.25*dhr0/preval#
drocinv <- rocinv(d, rx_true, v=0.8) - rocinv(d_un, rxy_un_2, v=0.8)#
droct <- roct(d_un, rxy_un_2, t=0.1) - roct(d, rx_true, t=0.1)#
dauc <- calcAuc(d_un, rxy_un_2) - calcAuc(d, rx_true)#
dmrd <- mean(rxy_un_2[d_un==1])-mean(rxy_un_2[d_un==0])-mean(rx_true[d==1])+mean(rx_true[d==0])#
daard <- fxy0(preval)-fxy1(preval)-fx0(preval)+fx1(preval)#
nri <- 2*(mean(rxy_un_2[d_un==1] > rx_true_un[d_un==1]) - mean(rxy_un_2[d_un==0] > rx_true_un[d_un==0])) #
ta <- cbind(ta, c(dhr1, dhr0, db, drocinv, droct, dauc, dmrd, daard, nri))#
######################################################
## get matched cc samples#
idx1_m <- idx_un[(n0+1):n]#
idx0_m <- NULL#
ss <- 2*sum(mv[idx1_m]==1)#
tmps <- sample(intersect(which(d==0), which(mv==1)), ss)#
idx0_m <- c(idx0_m, tmps)#
ss <- 2*sum(mv[idx1_m]==2)#
tmps <- sample(intersect(which(d==0), which(mv==2)), ss)#
idx0_m <- c(idx0_m, tmps)#
ss <- 2*sum(mv[idx1_m]==3)#
tmps <- sample(intersect(which(d==0), which(mv==3)), ss)#
idx0_m <- c(idx0_m, tmps)#
ss <- 2*sum(mv[idx1_m]==4)#
tmps <- sample(intersect(which(d==0), which(mv==4)), ss)#
idx0_m <- c(idx0_m, tmps)#
idx_m <- c(idx0_m, idx1_m)#
d_m <- c(rep(0, n0), rep(1, n1))#
x_m <- x[idx_m] #
y_m <- y[idx_m] #
mv_m <- mv[idx_m]#
rx_true_m <- rx_true[idx_m] #
spmod_m0 <- lm(y_m[d_m==0] ~ x_m[d_m==0])#
bint2 <- (summary(spmod_m0)$coefficients)[1]#
bx2 <- (summary(spmod_m0)$coefficients)[2]#
sigma2 <- summary(spmod_m0)$sigma#
err2 <- summary(spmod_m0)$resid#
spmod_m1 <- lm(y_m[d_m==1] ~ x_m[d_m==1])#
bint3 <- (summary(spmod_m1)$coefficients)[1]#
bx3 <- (summary(spmod_m1)$coefficients)[2]#
sigma3 <- summary(spmod_m1)$sigma#
err3 <- summary(spmod_m1)$resid#
# Madj approach#
rxy_m_M <- plogis(predict(glm(d_m~x_m+y_m, family=binomial("logit"))) + qlogis(preval) - qlogis(n1/n))#
fxy1 <- ecdf(rxy_m_M[d_m==1])#
s_case <- rxy_m_M[d_m==1]#
fs_case <- fxy1(s_case)#
fs_idx1 <- rank(s_case, ties.method="first")#
s_case[fs_idx1] <- s_case#
fs_case[fs_idx1] <- fs_case#
rs_prob_control <- length(intersect(which(mv==1), which(d==0))) / length(which(d==0))#
rs_prob_control <- rbind(rs_prob_control, length(intersect(which(mv==2), which(d==0))) / length(which(d==0)))#
rs_prob_control <- rbind(rs_prob_control, length(intersect(which(mv==3), which(d==0))) / length(which(d==0)))#
rs_prob_control <- rbind(rs_prob_control, length(intersect(which(mv==4), which(d==0))) / length(which(d==0)))#
s_control <- rxy_m_M[1:(sum(d[idx_m]==0))]#
rs_m_control <- mv_m[1:(sum(d[idx_m]==0))]#
ecdf_control_1 <- ecdf(s_control[which(rs_m_control==1)])#
ecdf_control_2 <- ecdf(s_control[which(rs_m_control==2)])#
ecdf_control_3 <- ecdf(s_control[which(rs_m_control==3)])#
ecdf_control_4 <- ecdf(s_control[which(rs_m_control==4)])#
fs_control <- cbind(ecdf_control_1(s_control), ecdf_control_2(s_control), ecdf_control_3(s_control), ecdf_control_4(s_control)) %*% rs_prob_control  #
fs_idx <- rank(s_control, ties.method="first")#
s_control[fs_idx] <- s_control#
fs_control[fs_idx] <- fs_control#
fxy0 <- function(r){#
	return(cbind(ecdf_control_1(r), ecdf_control_2(r), ecdf_control_3(r), ecdf_control_4(r)) %*% rs_prob_control)#
}#
roct_dlr <- function(t){#
	idx <- min(which(fs_control >= (1-t)))#
	return(1-fxy1(s_control[idx]))#
}#
roct_dlr2 <- function(t){#
	idx <- min(which(fs_case >= (1-t)))#
	return(1-fxy0(s_case[idx]))#
}#
dhr1 <- fx1(0.2) - fxy1(0.2)#
dhr0 <- fxy0(0.2) - fx0(0.2)#
db <- dhr1 + (1-preval)*0.25*dhr0/preval#
drocinv <- rocinv(d, rx_true, v=0.8) - roct_dlr2(0.8)#
droct <- roct_dlr(0.1) - roct(d, rx_true, t=0.1)#
dauc <- sum(fxy0(s_case))/n1 - calcAuc(d, rx_true)#
mrd1 <- cbind(mean(s_control[which(rs_m_control==1)]), mean(s_control[which(rs_m_control==2)]), mean(s_control[which(rs_m_control==3)]), mean(s_control[which(rs_m_control==4)]))%*% rs_prob_control #
dmrd <- mean(rxy_m_M[d_m==1])- mrd1 - mean(rx_true[d==1]) + mean(rx_true[d==0])#
daard <- fxy0(preval)-fxy1(preval)-fx0(preval)+fx1(preval)#
noneventnri <- mean(rxy_m_M[intersect(which(d_m==0), which(mv_m==1))] > rx_true_m[intersect(which(d_m==0), which(mv_m==1))])#
noneventnri <- cbind(noneventnri, mean(rxy_m_M[intersect(which(d_m==0), which(mv_m==2))] > rx_true_m[intersect(which(d_m==0), which(mv_m==2))]))#
noneventnri <- cbind(noneventnri, mean(rxy_m_M[intersect(which(d_m==0), which(mv_m==3))] > rx_true_m[intersect(which(d_m==0), which(mv_m==3))]))#
noneventnri <- cbind(noneventnri, mean(rxy_m_M[intersect(which(d_m==0), which(mv_m==4))] > rx_true_m[intersect(which(d_m==0), which(mv_m==4))]))#
nri <- 2*(mean(rxy_m_M[d_m==1] > rx_true_m[d_m==1]) - (noneventnri%*%rs_prob_control)) #
ta <- cbind(ta, c(dhr1, dhr0, db, drocinv, droct, dauc, dmrd, daard, nri))#
# 2-stage approach#
rxy_m_2 <- plogis(predict(glm(d_m~x_m+y_m, family=binomial("logit"))) + predx_true[idx_m] - predict(glm(d_m~x_m, family=binomial("logit"))))#
fxy1 <- ecdf(rxy_m_2[d_m==1])#
s_case <- rxy_m_2[d_m==1]#
fs_case <- fxy1(s_case)#
fs_idx1 <- rank(s_case, ties.method="first")#
s_case[fs_idx1] <- s_case#
fs_case[fs_idx1] <- fs_case#
s_control <- rxy_m_2[1:(sum(d[idx_m]==0))]#
rs_m_control <- mv_m[1:(sum(d[idx_m]==0))]#
ecdf_control_1 <- ecdf(s_control[which(rs_m_control==1)])#
ecdf_control_2 <- ecdf(s_control[which(rs_m_control==2)])#
ecdf_control_3 <- ecdf(s_control[which(rs_m_control==3)])#
ecdf_control_4 <- ecdf(s_control[which(rs_m_control==4)])#
fs_control <- cbind(ecdf_control_1(s_control), ecdf_control_2(s_control), ecdf_control_3(s_control), ecdf_control_4(s_control)) %*% rs_prob_control  #
fs_idx <- rank(s_control, ties.method="first")#
s_control[fs_idx] <- s_control#
fs_control[fs_idx] <- fs_control#
fxy0 <- function(r){#
	return(cbind(ecdf_control_1(r), ecdf_control_2(r), ecdf_control_3(r), ecdf_control_4(r)) %*% rs_prob_control)#
}#
roct_dlr <- function(t){#
	idx <- min(which(fs_control >= (1-t)))#
	return(1-fxy1(s_control[idx]))#
}#
roct_dlr2 <- function(t){#
	idx <- min(which(fs_case >= (1-t)))#
	return(1-fxy0(s_case[idx]))#
}#
dhr1 <- fx1(0.2) - fxy1(0.2)#
dhr0 <- fxy0(0.2) - fx0(0.2)#
db <- dhr1 + (1-preval)*0.25*dhr0/preval#
drocinv <- rocinv(d, rx_true, v=0.8) - roct_dlr2(0.8)#
droct <- roct_dlr(0.1) - roct(d, rx_true, t=0.1)#
dauc <- sum(fxy0(s_case))/n1 - calcAuc(d, rx_true)#
mrd1 <- cbind(mean(s_control[which(rs_m_control==1)]), mean(s_control[which(rs_m_control==2)]), mean(s_control[which(rs_m_control==3)]), mean(s_control[which(rs_m_control==4)]))%*% rs_prob_control #
dmrd <- mean(rxy_m_2[d_m==1])- mrd1 - mean(rx_true[d==1]) + mean(rx_true[d==0])#
daard <- fxy0(preval)-fxy1(preval)-fx0(preval)+fx1(preval)#
noneventnri <- mean(rxy_m_2[intersect(which(d_m==0), which(mv_m==1))] > rx_true_m[intersect(which(d_m==0), which(mv_m==1))])#
noneventnri <- cbind(noneventnri, mean(rxy_m_2[intersect(which(d_m==0), which(mv_m==2))] > rx_true_m[intersect(which(d_m==0), which(mv_m==2))]))#
noneventnri <- cbind(noneventnri, mean(rxy_m_2[intersect(which(d_m==0), which(mv_m==3))] > rx_true_m[intersect(which(d_m==0), which(mv_m==3))]))#
noneventnri <- cbind(noneventnri, mean(rxy_m_2[intersect(which(d_m==0), which(mv_m==4))] > rx_true_m[intersect(which(d_m==0), which(mv_m==4))]))#
nri <- 2*(mean(rxy_m_2[d_m==1] > rx_true_m[d_m==1]) - (noneventnri%*%rs_prob_control)) #
ta <- cbind(ta, c(dhr1, dhr0, db, drocinv, droct, dauc, dmrd, daard, nri))#
B <- 200#
bsrslt <- replicate(B, one.BS(d, x, mv, N, n0, n1, bint0, bx0, sigma0, err0, bint1, bx1, sigma1, err1, bint2, bx2, sigma2, err2, bint3, bx3, sigma3, err3))#
bssd <- apply(bsrslt, c(1,2), sd)#
rslt_sd <- abs((ta[,1:4] - trueval) / bssd) < qnorm(0.975)#
bsub <- apply(bsrslt, c(1,2), quantile, 0.975)#
bslb <- apply(bsrslt, c(1,2), quantile, 0.025)#
rslt_pe <- ((sign(bslb-trueval)*sign(bsub-trueval)) < 0)#
rslt <- cbind(rslt_sd, rslt_pe)#
row.names(rslt) <- c("dhr1", "dhr0", "db", "drocinv", "droct", "dauc", "dmrd", "daard", "nri")#
return(rslt)#
}#
######################################
# move on to 1000 simulation#
set.seed(101)#
###################### codes for getting the true summary values in a super large population
N <- 10^6  #Aasthaa made this change - using 10^6 instead of 10^7#
preval <- 0.1#
N1 <- N*preval#
N0 <- N - N1#
corr <- 0.5#
d <- c(rep(0, N0), rep(1, N1))#
xy <- rbind(rmvnorm(N0, c(0,0), matrix(c(1,corr,corr,1),2,2)), rmvnorm(N1, c(0.742,0.742), matrix(c(1,corr,corr,1),2,2)))#
x <- xy[,1]#
y <- xy[,2]#
xq <- quantile(x[d==0], c(0.25, 0.5, 0.75))#
mv <- rep(2, N)#
mv[x<xq[1]] <- 1#
mv[intersect(which(x<xq[3]), which(x>=xq[2]))] <- 3#
mv[x>=xq[3]] <- 4
get true values#
rx_true <- fitted(glm(d~x, family=binomial("logit")))#
predx_true <- predict(glm(d~x, family=binomial("logit")))#
rxy_true <- fitted(glm(d~x+y, family=binomial("logit")))#
fx0 <- ecdf(rx_true[d==0])#
fx1 <- ecdf(rx_true[d==1])#
fxy0 <- ecdf(rxy_true[d==0])#
fxy1 <- ecdf(rxy_true[d==1])#
dhr1 <- fx1(0.2) - fxy1(0.2)#
dhr0 <- fxy0(0.2) - fx0(0.2)#
db <- dhr1 + (1-preval)*0.25*dhr0/preval#
drocinv <- rocinv(d, rx_true, v=0.8) - rocinv(d, rxy_true, v=0.8)#
droct <- roct(d, rxy_true, t=0.1) - roct(d, rx_true, t=0.1)#
dauc <- calcAuc(d, rxy_true) - calcAuc(d, rx_true)#
dmrd <- mean(rxy_true[d==1])-mean(rxy_true[d==0])-mean(rx_true[d==1])+mean(rx_true[d==0])#
daard <- fxy0(preval)-fxy1(preval)-fx0(preval)+fx1(preval)#
nri <- 2*(mean(rxy_true[d==1] > rx_true[d==1]) - mean(rxy_true[d==0] > rx_true[d==0])) #
trueval <- c(dhr1, dhr0, db, drocinv, droct, dauc, dmrd, daard, nri)
specify the number of simulations#
nsim <- 1000#
rslt <- replicate(nsim, do.one(trueval))#
save.image("/Users/aasthaa/Dropbox/Dissertation/2-stage/LDAPaper/JingCode_1000sims.RData")
results <- list(length=2)
results
?list
results
results1 <- list()
results
results1
results[[1]] <- matrix(c(1,2,3,4),nrow=2)#
results[[2]] <- matrix(c(1,2,3,4),nrow=4)
results
results1 <- list()#
results1[[1]] <- matrix(c(1,2,3,4),nrow=2)#
results1[[2]] <- matrix(c(1,2,3,4),nrow=4)
results1
results <- list()
rm(list=ls())
library(mvtnorm)
Calculate percentile values using empirical method#
pcval <- function(d, y, tiecorr) {#
	n_db <- length(d[d==0])#
	Y_db <- sort(y[1:n_db])#
	y_j <- sort(y[(n_db+1):length(y)])#
	# Calculate P(Y_db <= y_j)#
	F_le <- ecdf(Y_db)#
	# Calculate P(Y_db < y_j)#
	y_j_neg <- -(y_j)#
	Y_db_neg <- -(Y_db)#
	F_l_neg <- ecdf(Y_db_neg)#
	F_l <- rep(1, length(y_j)) - F_l_neg(y_j_neg)#
	if(!tiecorr)#
		pcv_j <- F_l		# P(Y_db < y_j)#
	else #
		pcv_j <- F_l + 0.5*(F_le(y_j) - F_l)	# P(Y_db < y_j) + 0.5*P(Y_db = y_j)#
	return(pcv_j)#
}#
# Get ROC value at given t#
roct <- function(d, y, tiecorr=FALSE, t) {#
	pcvals <- pcval(d, y, tiecorr)#
	F_pl <- ecdf(1-pcvals)#
	return(F_pl(t))#
}#
# Get inverse of ROC function, at a given TPF=v#
rocinv <- function(d, y, tiecorr=FALSE, v) {#
	d_new <- 1-d#
	y_new <- -y#
	dataset_new <- as.data.frame(cbind(y_new, d_new))#
	dataset_new <- dataset_new[order(dataset_new$d_new),]#
	pcvals <- pcval(dataset_new$d_new, dataset_new$y_new, tiecorr)#
	FPF_new <- 1-pcvals#
	F_pl_new <- ecdf(FPF_new)#
	TPF_new <- F_pl_new(FPF_new)#
	return(1 - F_pl_new(1-v))#
}#
# Get AUC for ROC curve#
calcAuc <- function(d, y, tiecorr=FALSE) {#
	return(mean(pcval(d, y, tiecorr)))#
}
one.BS <- function(orid, orix, orimv, N, n0, n1, bint0, bx0, sigma0, err0, bint1, bx1, sigma1, err1, #
	bint2, bx2, sigma2, err2, bint3, bx3, sigma3, err3){#
	n <- n0 + n1#
	ta <- NULL	#
	idx <- sort(sample(N, N, replace=T)) # make sure we get d with controls coming first and then cases#
	d <- orid[idx]#
	x <- orix[idx]#
	mv <- orimv[idx]#
	preval <- sum(d)/N#
	rx_true <- fitted(glm(d~x, family=binomial("logit")))#
	predx_true <- predict(glm(d~x, family=binomial("logit")))#
	fx0 <- ecdf(rx_true[d==0])#
	fx1 <- ecdf(rx_true[d==1])#
	idx_un <- c(sample(which(d==0), n0), sample(which(d==1), n1))#
	d_un <- d[idx_un]#
	x_un <- x[idx_un] #
	y_un <- c((bint0+bx0*(x_un[d_un==0])+sigma0*sample(err0, n0, replace=T)), (bint1+bx1*(x_un[d_un==1])+sigma1*sample(err1, n1, replace=T)))#
	rx_true_un <- rx_true[idx_un] #
	# Madj approach#
	rxy_un_M <- plogis(predict(glm(d_un~x_un+y_un, family=binomial("logit"))) + qlogis(preval) - qlogis(n1/n))#
	fxy0 <- ecdf(rxy_un_M[d_un==0])#
	fxy1 <- ecdf(rxy_un_M[d_un==1])#
	dhr1 <- fx1(0.2) - fxy1(0.2)#
	dhr0 <- fxy0(0.2) - fx0(0.2)#
	db <- dhr1 + (1-preval)*0.25*dhr0/preval#
	drocinv <- rocinv(d, rx_true, v=0.8) - rocinv(d_un, rxy_un_M, v=0.8)#
	droct <- roct(d_un, rxy_un_M, t=0.1) - roct(d, rx_true, t=0.1)#
	dauc <- calcAuc(d_un, rxy_un_M) - calcAuc(d, rx_true)#
	dmrd <- mean(rxy_un_M[d_un==1])-mean(rxy_un_M[d_un==0])-mean(rx_true[d==1])+mean(rx_true[d==0])#
	daard <- fxy0(preval)-fxy1(preval)-fx0(preval)+fx1(preval)#
	nri <- 2*(mean(rxy_un_M[d_un==1] > rx_true_un[d_un==1]) - mean(rxy_un_M[d_un==0] > rx_true_un[d_un==0])) #
	ta <- cbind(ta, c(dhr1, dhr0, db, drocinv, droct, dauc, dmrd, daard, nri))#
	# 2-stage approach	#
	rxy_un_2 <- plogis(predict(glm(d_un~x_un+y_un, family=binomial("logit"))) + predx_true[idx_un] - predict(glm(d_un~x_un, family=binomial("logit"))))#
	fxy0 <- ecdf(rxy_un_2[d_un==0])#
	fxy1 <- ecdf(rxy_un_2[d_un==1])#
	dhr1 <- fx1(0.2) - fxy1(0.2)#
	dhr0 <- fxy0(0.2) - fx0(0.2)#
	db <- dhr1 + (1-preval)*0.25*dhr0/preval#
	drocinv <- rocinv(d, rx_true, v=0.8) - rocinv(d_un, rxy_un_2, v=0.8)#
	droct <- roct(d_un, rxy_un_2, t=0.1) - roct(d, rx_true, t=0.1)#
	dauc <- calcAuc(d_un, rxy_un_2) - calcAuc(d, rx_true)#
	dmrd <- mean(rxy_un_2[d_un==1])-mean(rxy_un_2[d_un==0])-mean(rx_true[d==1])+mean(rx_true[d==0])#
	daard <- fxy0(preval)-fxy1(preval)-fx0(preval)+fx1(preval)#
	nri <- 2*(mean(rxy_un_2[d_un==1] > rx_true_un[d_un==1]) - mean(rxy_un_2[d_un==0] > rx_true_un[d_un==0])) #
	ta <- cbind(ta, c(dhr1, dhr0, db, drocinv, droct, dauc, dmrd, daard, nri))#
	# get matched cc samples#
	idx1_m <- idx_un[(n0+1):n] # make sure idx_un gives controls first and then cases #
	idx0_m <- NULL#
	ss <- 2*sum(mv[idx1_m]==1)#
	tmps <- sample(intersect(which(d==0), which(mv==1)), ss)#
	idx0_m <- c(idx0_m, tmps)#
	ss <- 2*sum(mv[idx1_m]==2)#
	tmps <- sample(intersect(which(d==0), which(mv==2)), ss)#
	idx0_m <- c(idx0_m, tmps)#
	ss <- 2*sum(mv[idx1_m]==3)#
	tmps <- sample(intersect(which(d==0), which(mv==3)), ss)#
	idx0_m <- c(idx0_m, tmps)#
	ss <- 2*sum(mv[idx1_m]==4)#
	tmps <- sample(intersect(which(d==0), which(mv==4)), ss)#
	idx0_m <- c(idx0_m, tmps)#
	idx_m <- c(idx0_m, idx1_m)#
	d_m <- c(rep(0, n0), rep(1, n1))#
	x_m <- x[idx_m] #
	y_m <- c((bint2+bx2*(x_m[d_m==0])+sigma2*sample(err2, n0, replace=T)), (bint3+bx3*(x_m[d_m==1])+sigma3*sample(err3, n1, replace=T)))#
	mv_m <- mv[idx_m]#
	rx_true_m <- rx_true[idx_m] #
	# Madj approach#
	rxy_m_M <- plogis(predict(glm(d_m~x_m+y_m, family=binomial("logit"))) + qlogis(preval) - qlogis(n1/n))#
	fxy1 <- ecdf(rxy_m_M[d_m==1])#
	s_case <- rxy_m_M[d_m==1]#
	fs_case <- fxy1(s_case)#
	fs_idx1 <- rank(s_case, ties.method="first")#
	s_case[fs_idx1] <- s_case#
	fs_case[fs_idx1] <- fs_case#
	rs_prob_control <- length(intersect(which(mv==1), which(d==0))) / length(which(d==0))#
	rs_prob_control <- rbind(rs_prob_control, length(intersect(which(mv==2), which(d==0))) / length(which(d==0)))#
	rs_prob_control <- rbind(rs_prob_control, length(intersect(which(mv==3), which(d==0))) / length(which(d==0)))#
	rs_prob_control <- rbind(rs_prob_control, length(intersect(which(mv==4), which(d==0))) / length(which(d==0)))#
	s_control <- rxy_m_M[1:(sum(d[idx_m]==0))]#
	rs_m_control <- mv_m[1:(sum(d[idx_m]==0))]#
	ecdf_control_1 <- ecdf(s_control[which(rs_m_control==1)])#
	ecdf_control_2 <- ecdf(s_control[which(rs_m_control==2)])#
	ecdf_control_3 <- ecdf(s_control[which(rs_m_control==3)])#
	ecdf_control_4 <- ecdf(s_control[which(rs_m_control==4)])#
	fs_control <- cbind(ecdf_control_1(s_control), ecdf_control_2(s_control), ecdf_control_3(s_control), ecdf_control_4(s_control)) %*% rs_prob_control  #
	fs_idx <- rank(s_control, ties.method="first")#
	s_control[fs_idx] <- s_control#
	fs_control[fs_idx] <- fs_control#
	fxy0 <- function(r){#
		return(cbind(ecdf_control_1(r), ecdf_control_2(r), ecdf_control_3(r), ecdf_control_4(r)) %*% rs_prob_control)#
	}#
	roct_dlr <- function(t){#
		idx <- min(which(fs_control >= (1-t)))#
		return(1-fxy1(s_control[idx]))#
	}#
	roct_dlr2 <- function(t){#
		idx <- min(which(fs_case >= (1-t)))#
		return(1-fxy0(s_case[idx]))#
	}#
	dhr1 <- fx1(0.2) - fxy1(0.2)#
	dhr0 <- fxy0(0.2) - fx0(0.2)#
	db <- dhr1 + (1-preval)*0.25*dhr0/preval#
	drocinv <- rocinv(d, rx_true, v=0.8) - roct_dlr2(0.8)#
	droct <- roct_dlr(0.1) - roct(d, rx_true, t=0.1)#
	dauc <- sum(fxy0(s_case))/n1 - calcAuc(d, rx_true)#
	mrd1 <- cbind(mean(s_control[which(rs_m_control==1)]), mean(s_control[which(rs_m_control==2)]), mean(s_control[which(rs_m_control==3)]), mean(s_control[which(rs_m_control==4)]))%*% rs_prob_control #
	dmrd <- mean(rxy_m_M[d_m==1])- mrd1 - mean(rx_true[d==1]) + mean(rx_true[d==0])#
	daard <- fxy0(preval)-fxy1(preval)-fx0(preval)+fx1(preval)#
	noneventnri <- mean(rxy_m_M[intersect(which(d_m==0), which(mv_m==1))] > rx_true_m[intersect(which(d_m==0), which(mv_m==1))])#
	noneventnri <- cbind(noneventnri, mean(rxy_m_M[intersect(which(d_m==0), which(mv_m==2))] > rx_true_m[intersect(which(d_m==0), which(mv_m==2))]))#
	noneventnri <- cbind(noneventnri, mean(rxy_m_M[intersect(which(d_m==0), which(mv_m==3))] > rx_true_m[intersect(which(d_m==0), which(mv_m==3))]))#
	noneventnri <- cbind(noneventnri, mean(rxy_m_M[intersect(which(d_m==0), which(mv_m==4))] > rx_true_m[intersect(which(d_m==0), which(mv_m==4))]))#
	nri <- 2*(mean(rxy_m_M[d_m==1] > rx_true_m[d_m==1]) - (noneventnri%*%rs_prob_control)) #
	ta <- cbind(ta, c(dhr1, dhr0, db, drocinv, droct, dauc, dmrd, daard, nri))#
	# 2-stage approach#
	rxy_m_2 <- plogis(predict(glm(d_m~x_m+y_m, family=binomial("logit"))) + predx_true[idx_m] - predict(glm(d_m~x_m, family=binomial("logit"))))#
	fxy1 <- ecdf(rxy_m_2[d_m==1])#
	s_case <- rxy_m_2[d_m==1]#
	fs_case <- fxy1(s_case)#
	fs_idx1 <- rank(s_case, ties.method="first")#
	s_case[fs_idx1] <- s_case#
	fs_case[fs_idx1] <- fs_case#
	s_control <- rxy_m_2[1:(sum(d[idx_m]==0))]#
	rs_m_control <- mv_m[1:(sum(d[idx_m]==0))]#
	ecdf_control_1 <- ecdf(s_control[which(rs_m_control==1)])#
	ecdf_control_2 <- ecdf(s_control[which(rs_m_control==2)])#
	ecdf_control_3 <- ecdf(s_control[which(rs_m_control==3)])#
	ecdf_control_4 <- ecdf(s_control[which(rs_m_control==4)])#
	fs_control <- cbind(ecdf_control_1(s_control), ecdf_control_2(s_control), ecdf_control_3(s_control), ecdf_control_4(s_control)) %*% rs_prob_control  #
	fs_idx <- rank(s_control, ties.method="first")#
	s_control[fs_idx] <- s_control#
	fs_control[fs_idx] <- fs_control#
	fxy0 <- function(r){#
		return(cbind(ecdf_control_1(r), ecdf_control_2(r), ecdf_control_3(r), ecdf_control_4(r)) %*% rs_prob_control)#
	}#
	roct_dlr <- function(t){#
		idx <- min(which(fs_control >= (1-t)))#
		return(1-fxy1(s_control[idx]))#
	}#
	roct_dlr2 <- function(t){#
		idx <- min(which(fs_case >= (1-t)))#
		return(1-fxy0(s_case[idx]))#
	}#
	dhr1 <- fx1(0.2) - fxy1(0.2)#
	dhr0 <- fxy0(0.2) - fx0(0.2)#
	db <- dhr1 + (1-preval)*0.25*dhr0/preval#
	drocinv <- rocinv(d, rx_true, v=0.8) - roct_dlr2(0.8)#
	droct <- roct_dlr(0.1) - roct(d, rx_true, t=0.1)#
	dauc <- sum(fxy0(s_case))/n1 - calcAuc(d, rx_true)#
	mrd1 <- cbind(mean(s_control[which(rs_m_control==1)]), mean(s_control[which(rs_m_control==2)]), mean(s_control[which(rs_m_control==3)]), mean(s_control[which(rs_m_control==4)]))%*% rs_prob_control #
	dmrd <- mean(rxy_m_2[d_m==1])- mrd1 - mean(rx_true[d==1]) + mean(rx_true[d==0])#
	daard <- fxy0(preval)-fxy1(preval)-fx0(preval)+fx1(preval)#
	noneventnri <- mean(rxy_m_2[intersect(which(d_m==0), which(mv_m==1))] > rx_true_m[intersect(which(d_m==0), which(mv_m==1))])#
	noneventnri <- cbind(noneventnri, mean(rxy_m_2[intersect(which(d_m==0), which(mv_m==2))] > rx_true_m[intersect(which(d_m==0), which(mv_m==2))]))#
	noneventnri <- cbind(noneventnri, mean(rxy_m_2[intersect(which(d_m==0), which(mv_m==3))] > rx_true_m[intersect(which(d_m==0), which(mv_m==3))]))#
	noneventnri <- cbind(noneventnri, mean(rxy_m_2[intersect(which(d_m==0), which(mv_m==4))] > rx_true_m[intersect(which(d_m==0), which(mv_m==4))]))#
	nri <- 2*(mean(rxy_m_2[d_m==1] > rx_true_m[d_m==1]) - (noneventnri%*%rs_prob_control)) #
	ta <- cbind(ta, c(dhr1, dhr0, db, drocinv, droct, dauc, dmrd, daard, nri))#
	return(ta)#
}
ls()
rm(list=ls())
ls()
rm(list=ls())
setwd("/Users/aasthaa/Dropbox/JobSearch/Webpage")
install.packages("wordcloud")#
library(wordcloud)#
#
install.packages("tm")#
library(tm)
source("googleCite.r")
source("googleCite.r")
> #
#   Some functions to quantify your Google Scholar citations page. #
#   R functions Copyright (C) 2011 John Muschelli (jmuschel
getwd()
csvFile <- "testFile.csv"
words <- read.csv(csvFile, header=F)
words <- read.csv(csvFile, header=F)
words
is.list(words)
words <- as.character(unlist(words[,-1]))
words
words <- read.csv(csvFile, header=F)#
  words <- as.character(unlist(words))
words
words <- as.vector(unlist(sapply(words, function(x) strsplit(x, split=","))))
words
words <- read.csv(csvFile, header=F)#
  words <- as.character(unlist(words))
words
words <- sapply(words, function(x) paste("\"", x, "\"", sep=""))
words
myCorpus <- Corpus(DataframeSource(data.frame(words)))#
  #myCorpus <- tm_map(myCorpus, removePunctuation)#
  #myCorpus <- tm_map(myCorpus, tolower)#
  #myCorpus <- tm_map(myCorpus, function(x) removeWords(x, stopwords("english")))#
  tdm <- TermDocumentMatrix(myCorpus, control=list(tolower=F))#
  m <- as.matrix(tdm)#
  v <- sort(rowSums(m),decreasing=TRUE)#
  d <- data.frame(word = names(v), freq=v)
palRed = brewer.pal(9, "Reds")#
  palGrey = brewer.pal(9, "Greys")#
  pal <- c(palGrey[c(5,9)], palRed[7:9])
wordcloud(words = d$word, freq = d$freq, #
            min.freq = 1, max.words = Inf,
wordcloud(words = d$word, freq = d$freq, #
            min.freq = 1, max.words = Inf,#
            random.order = FALSE, colors = pal)
d
wordcloud(words = d$word, freq = d$freq, #
            min.freq = 1, max.words = Inf,#
            random.order = FALSE, colors = pal)
dev.off()
words <- read.csv(csvFile, header=F)#
  words <- as.character(unlist(words))
myCorpus <- Corpus(DataframeSource(data.frame(words)))#
  #myCorpus <- tm_map(myCorpus, removePunctuation)#
  #myCorpus <- tm_map(myCorpus, tolower)#
  #myCorpus <- tm_map(myCorpus, function(x) removeWords(x, stopwords("english")))#
  tdm <- TermDocumentMatrix(myCorpus, control=list(tolower=F))#
  m <- as.matrix(tdm)#
  v <- sort(rowSums(m),decreasing=TRUE)#
  d <- data.frame(word = names(v), freq=v)
d
words
myCorpus <- Corpus(DataframeSource(data.frame(words)))
myCorpus
tdm <- TermDocumentMatrix(myCorpus, control=list(tolower=F))#
  m <- as.matrix(tdm)
m
tdm
words <- sapply(words, function(x) paste("\"", x, "\"", sep=""))
words
myCorpus <- Corpus(DataframeSource(data.frame(words)))
tdm <- TermDocumentMatrix(myCorpus, control=list(tolower=F))#
  m <- as.matrix(tdm)#
  v <- sort(rowSums(m),decreasing=TRUE)#
  d <- data.frame(word = names(v), freq=v)
d
words
is.vector(words)
d$word
as.character(words)
as.character(d$word)
words <- read.csv(csvFile, header=F)#
  words <- as.character(unlist(words))#
  words <- sapply(words, function(x) paste("\"", x, "\"", sep=""))
words
myCorpus <- Corpus(DataframeSource(data.frame(words)))
tdm <- TermDocumentMatrix(myCorpus, control=list(tolower=F))#
  m <- as.matrix(tdm)
m
v <- sort(rowSums(m),decreasing=TRUE)
v
is.vector(v)
names(v)
words <- d$word
words
words <- as.character(d$word)
words
strsplit(words[1], split="\"")
words <- as.character(d$word)#
  words <- as.vector(unlist(sapply(words, function(x) (strsplit(x, split="\""))[2] )))
words
words <- as.character(d$word)
words
sapply(words, function(x) (strsplit(x, split="\""))[2] )
words <- as.character(d$word)
strsplit(words[1], split="\"")
test <- strsplit(words[1], split="\"")
length(test)
test[[1]]
test1 <- test[[1]]
test1
length(test1)
test1[2]
as.character(test1[2])
words <- as.character(d$word)#
  words <- as.vector(unlist(sapply(words, function(x) ((strsplit(x, split="\""))[[1]])[2] )))
words
wordcloud(words = d$word, freq = d$freq, #
            min.freq = 1, max.words = Inf,#
            random.order = FALSE, colors = pal)
d$word <- words
wordcloud(words = d$word, freq = d$freq, #
            min.freq = 1, max.words = Inf,#
            random.order = FALSE, colors = pal)
wordcloud(words = d$word, freq = d$freq, #
            min.freq = 1, max.words = Inf,#
            random.order = FALSE, colors = pal)
rm(list=ls())
setwd("/Users/aasthaa/Dropbox/JobSearch/Webpage")#
#
install.packages("wordcloud")#
library(wordcloud)#
#
install.packages("tm")#
library(tm)
source("makePaperCloud_manual.R")#
makePaperCloud_manual("testFile.csv", "testOut.pdf")
dev.off()
makePaperCloud_manual("testFile.csv", "testOut.pnf")
makePaperCloud_manual("testFile.csv", "testOut.png")
